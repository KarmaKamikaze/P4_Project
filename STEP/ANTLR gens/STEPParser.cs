//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.9.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/Mikkel/Documents/Codebase/STEP/STEP/ANTLR gens\STEP.g4 by ANTLR 4.9.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.9.2")]
[System.CLSCompliant(false)]
public partial class STEPParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		WHITESPACE=1, END_OF_LINE_COMMENT=2, MULTILINE_COMMENT=3, LPAREN=4, RPAREN=5, 
		LBRACK=6, RBRACK=7, ASSIGN=8, PLUS=9, MINUS=10, DIVIDE=11, MULT=12, POW=13, 
		GRTHAN=14, GRTHANEQ=15, LTHAN=16, LTHANEQ=17, EQ=18, NEQ=19, NEG=20, NL=21, 
		COMMA=22, INTLITERAL=23, NUMLITERAL=24, STRLITERAL=25, BOOLLITERAL=26, 
		SETUP=27, ENDSETUP=28, LOOP=29, ENDLOOP=30, FUNCTIONS=31, ENDFUNCTIONS=32, 
		FUNCTION=33, ENDFUNCTION=34, VARIABLES=35, ENDVARIABLES=36, BLANK=37, 
		NUMBER=38, STRING=39, BOOLEAN=40, ANALOGPIN=41, DIGITALPIN=42, IF=43, 
		ENDIF=44, ELSE=45, CONTINUE=46, BREAK=47, REPEATWHILE=48, ENDWHILE=49, 
		REPEATFOR=50, ENDFOR=51, TO=52, CHANGEBY=53, SWITCH=54, ENDSWITCH=55, 
		WHEN=56, DO=57, FALLTHROUGH=58, OTHERWISEDO=59, RETURN=60, AND=61, OR=62, 
		CONSTANT=63, INPUT=64, OUTPUT=65, ID=66;
	public const int
		RULE_program = 0, RULE_setuploop = 1, RULE_setup = 2, RULE_loop = 3, RULE_variables = 4, 
		RULE_var_or_nl = 5, RULE_functions = 6, RULE_funcdcl = 7, RULE_funcdcl_or_nl = 8, 
		RULE_brackets = 9, RULE_params = 10, RULE_params_content = 11, RULE_params_multi = 12, 
		RULE_type = 13, RULE_paramstype = 14, RULE_stmt = 15, RULE_stmts = 16, 
		RULE_loop_stmt = 17, RULE_loop_stmts = 18, RULE_loopifbody = 19, RULE_ifstmt = 20, 
		RULE_elseifstmt = 21, RULE_elsestmt = 22, RULE_loopifstmt = 23, RULE_loopelseifstmt = 24, 
		RULE_loopelsestmt = 25, RULE_whilestmt = 26, RULE_forstmt = 27, RULE_for_iter_opt = 28, 
		RULE_assstmt = 29, RULE_funccall = 30, RULE_params_options = 31, RULE_multi_expr = 32, 
		RULE_retstmt = 33, RULE_arrindex = 34, RULE_expr = 35, RULE_term = 36, 
		RULE_factor = 37, RULE_value = 38, RULE_constant = 39, RULE_logicexpr = 40, 
		RULE_logicequal = 41, RULE_logiccomp = 42, RULE_logiccompop = 43, RULE_logicvalue = 44, 
		RULE_vardcl = 45, RULE_var_options = 46, RULE_numdcl = 47, RULE_stringdcl = 48, 
		RULE_booldcl = 49, RULE_pindcl = 50, RULE_pinmode = 51, RULE_pintype = 52, 
		RULE_arrdcl = 53, RULE_arr_id_or_lit = 54, RULE_arrsizedcl = 55;
	public static readonly string[] ruleNames = {
		"program", "setuploop", "setup", "loop", "variables", "var_or_nl", "functions", 
		"funcdcl", "funcdcl_or_nl", "brackets", "params", "params_content", "params_multi", 
		"type", "paramstype", "stmt", "stmts", "loop_stmt", "loop_stmts", "loopifbody", 
		"ifstmt", "elseifstmt", "elsestmt", "loopifstmt", "loopelseifstmt", "loopelsestmt", 
		"whilestmt", "forstmt", "for_iter_opt", "assstmt", "funccall", "params_options", 
		"multi_expr", "retstmt", "arrindex", "expr", "term", "factor", "value", 
		"constant", "logicexpr", "logicequal", "logiccomp", "logiccompop", "logicvalue", 
		"vardcl", "var_options", "numdcl", "stringdcl", "booldcl", "pindcl", "pinmode", 
		"pintype", "arrdcl", "arr_id_or_lit", "arrsizedcl"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, "'('", "')'", "'['", "']'", "'='", "'+'", "'-'", 
		"'/'", "'*'", "'^'", "'>'", "'>='", "'<'", "'<='", "'=='", "'!:'", "'!'", 
		null, "','", null, null, null, null, "'setup'", "'end setup'", "'loop'", 
		"'end loop'", "'functions'", "'end functions'", "'function'", "'end function'", 
		"'variables'", "'end variables'", "'blank'", "'number'", "'string'", "'boolean'", 
		"'analogpin'", "'digitalpin'", "'if'", "'end if'", "'else'", "'continue'", 
		"'break'", "'repeat while'", "'end while'", "'repeat for'", "'end for'", 
		"'to'", "'change by'", "'switch'", "'end switch'", "'when'", "'do'", "'fallthrough'", 
		"'otherwise do'", "'return'", "'and'", "'or'", "'constant'", "'input'", 
		"'output'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WHITESPACE", "END_OF_LINE_COMMENT", "MULTILINE_COMMENT", "LPAREN", 
		"RPAREN", "LBRACK", "RBRACK", "ASSIGN", "PLUS", "MINUS", "DIVIDE", "MULT", 
		"POW", "GRTHAN", "GRTHANEQ", "LTHAN", "LTHANEQ", "EQ", "NEQ", "NEG", "NL", 
		"COMMA", "INTLITERAL", "NUMLITERAL", "STRLITERAL", "BOOLLITERAL", "SETUP", 
		"ENDSETUP", "LOOP", "ENDLOOP", "FUNCTIONS", "ENDFUNCTIONS", "FUNCTION", 
		"ENDFUNCTION", "VARIABLES", "ENDVARIABLES", "BLANK", "NUMBER", "STRING", 
		"BOOLEAN", "ANALOGPIN", "DIGITALPIN", "IF", "ENDIF", "ELSE", "CONTINUE", 
		"BREAK", "REPEATWHILE", "ENDWHILE", "REPEATFOR", "ENDFOR", "TO", "CHANGEBY", 
		"SWITCH", "ENDSWITCH", "WHEN", "DO", "FALLTHROUGH", "OTHERWISEDO", "RETURN", 
		"AND", "OR", "CONSTANT", "INPUT", "OUTPUT", "ID"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "STEP.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static STEPParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public STEPParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public STEPParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SetuploopContext setuploop() {
			return GetRuleContext<SetuploopContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(STEPParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(STEPParser.NL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariablesContext variables() {
			return GetRuleContext<VariablesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionsContext functions() {
			return GetRuleContext<FunctionsContext>(0);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 115;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NL) {
				{
				{
				State = 112;
				Match(NL);
				}
				}
				State = 117;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 119;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VARIABLES) {
				{
				State = 118;
				variables();
				}
			}

			State = 121;
			setuploop();
			State = 123;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FUNCTIONS) {
				{
				State = 122;
				functions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetuploopContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SetupContext setup() {
			return GetRuleContext<SetupContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(STEPParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(STEPParser.NL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopContext loop() {
			return GetRuleContext<LoopContext>(0);
		}
		public SetuploopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setuploop; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterSetuploop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitSetuploop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetuploop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetuploopContext setuploop() {
		SetuploopContext _localctx = new SetuploopContext(Context, State);
		EnterRule(_localctx, 2, RULE_setuploop);
		int _la;
		try {
			State = 153;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 125;
				setup();
				State = 129;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==NL) {
					{
					{
					State = 126;
					Match(NL);
					}
					}
					State = 131;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 132;
				loop();
				State = 136;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==NL) {
					{
					{
					State = 133;
					Match(NL);
					}
					}
					State = 138;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 139;
				setup();
				State = 143;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==NL) {
					{
					{
					State = 140;
					Match(NL);
					}
					}
					State = 145;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 146;
				loop();
				State = 150;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==NL) {
					{
					{
					State = 147;
					Match(NL);
					}
					}
					State = 152;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetupContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETUP() { return GetToken(STEPParser.SETUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDSETUP() { return GetToken(STEPParser.ENDSETUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		public SetupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setup; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterSetup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitSetup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetupContext setup() {
		SetupContext _localctx = new SetupContext(Context, State);
		EnterRule(_localctx, 4, RULE_setup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 155;
			Match(SETUP);
			State = 159;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 156;
				stmt();
				}
				}
				State = 161;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 162;
			Match(ENDSETUP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOP() { return GetToken(STEPParser.LOOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDLOOP() { return GetToken(STEPParser.ENDLOOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		public LoopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopContext loop() {
		LoopContext _localctx = new LoopContext(Context, State);
		EnterRule(_localctx, 6, RULE_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 164;
			Match(LOOP);
			State = 168;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 165;
				stmt();
				}
				}
				State = 170;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 171;
			Match(ENDLOOP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariablesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARIABLES() { return GetToken(STEPParser.VARIABLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDVARIABLES() { return GetToken(STEPParser.ENDVARIABLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Var_or_nlContext[] var_or_nl() {
			return GetRuleContexts<Var_or_nlContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Var_or_nlContext var_or_nl(int i) {
			return GetRuleContext<Var_or_nlContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(STEPParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(STEPParser.NL, i);
		}
		public VariablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variables; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterVariables(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitVariables(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariables(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariablesContext variables() {
		VariablesContext _localctx = new VariablesContext(Context, State);
		EnterRule(_localctx, 8, RULE_variables);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(VARIABLES);
			State = 177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (CONSTANT - 21)) | (1L << (INPUT - 21)) | (1L << (OUTPUT - 21)))) != 0)) {
				{
				{
				State = 174;
				var_or_nl();
				}
				}
				State = 179;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 180;
			Match(ENDVARIABLES);
			State = 184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NL) {
				{
				{
				State = 181;
				Match(NL);
				}
				}
				State = 186;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Var_or_nlContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VardclContext vardcl() {
			return GetRuleContext<VardclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PindclContext pindcl() {
			return GetRuleContext<PindclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL() { return GetToken(STEPParser.NL, 0); }
		public Var_or_nlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_var_or_nl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterVar_or_nl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitVar_or_nl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVar_or_nl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Var_or_nlContext var_or_nl() {
		Var_or_nlContext _localctx = new Var_or_nlContext(Context, State);
		EnterRule(_localctx, 10, RULE_var_or_nl);
		try {
			State = 190;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NUMBER:
			case STRING:
			case BOOLEAN:
			case CONSTANT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 187;
				vardcl();
				}
				break;
			case INPUT:
			case OUTPUT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 188;
				pindcl();
				}
				break;
			case NL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 189;
				Match(NL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTIONS() { return GetToken(STEPParser.FUNCTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDFUNCTIONS() { return GetToken(STEPParser.ENDFUNCTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Funcdcl_or_nlContext[] funcdcl_or_nl() {
			return GetRuleContexts<Funcdcl_or_nlContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Funcdcl_or_nlContext funcdcl_or_nl(int i) {
			return GetRuleContext<Funcdcl_or_nlContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(STEPParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(STEPParser.NL, i);
		}
		public FunctionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterFunctions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitFunctions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionsContext functions() {
		FunctionsContext _localctx = new FunctionsContext(Context, State);
		EnterRule(_localctx, 12, RULE_functions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 192;
			Match(FUNCTIONS);
			State = 196;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NL) | (1L << BLANK) | (1L << NUMBER) | (1L << STRING) | (1L << BOOLEAN))) != 0)) {
				{
				{
				State = 193;
				funcdcl_or_nl();
				}
				}
				State = 198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 199;
			Match(ENDFUNCTIONS);
			State = 203;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NL) {
				{
				{
				State = 200;
				Match(NL);
				}
				}
				State = 205;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncdclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(STEPParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParamsContext @params() {
			return GetRuleContext<ParamsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RetstmtContext retstmt() {
			return GetRuleContext<RetstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(STEPParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(STEPParser.NL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDFUNCTION() { return GetToken(STEPParser.ENDFUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BracketsContext brackets() {
			return GetRuleContext<BracketsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLANK() { return GetToken(STEPParser.BLANK, 0); }
		public FuncdclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcdcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterFuncdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitFuncdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncdclContext funcdcl() {
		FuncdclContext _localctx = new FuncdclContext(Context, State);
		EnterRule(_localctx, 14, RULE_funcdcl);
		int _la;
		try {
			int _alt;
			State = 237;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NUMBER:
			case STRING:
			case BOOLEAN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 206;
				type();
				State = 208;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LBRACK) {
					{
					State = 207;
					brackets();
					}
				}

				State = 210;
				Match(FUNCTION);
				State = 211;
				Match(ID);
				State = 212;
				@params();
				State = 216;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 213;
						stmt();
						}
						} 
					}
					State = 218;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
				}
				State = 219;
				retstmt();
				State = 220;
				Match(NL);
				State = 221;
				Match(ENDFUNCTION);
				State = 222;
				Match(NL);
				}
				break;
			case BLANK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 224;
				Match(BLANK);
				State = 225;
				Match(FUNCTION);
				State = 226;
				Match(ID);
				State = 227;
				@params();
				State = 231;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
					{
					{
					State = 228;
					stmt();
					}
					}
					State = 233;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 234;
				Match(ENDFUNCTION);
				State = 235;
				Match(NL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Funcdcl_or_nlContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FuncdclContext funcdcl() {
			return GetRuleContext<FuncdclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL() { return GetToken(STEPParser.NL, 0); }
		public Funcdcl_or_nlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcdcl_or_nl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterFuncdcl_or_nl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitFuncdcl_or_nl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdcl_or_nl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Funcdcl_or_nlContext funcdcl_or_nl() {
		Funcdcl_or_nlContext _localctx = new Funcdcl_or_nlContext(Context, State);
		EnterRule(_localctx, 16, RULE_funcdcl_or_nl);
		try {
			State = 241;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BLANK:
			case NUMBER:
			case STRING:
			case BOOLEAN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 239;
				funcdcl();
				}
				break;
			case NL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 240;
				Match(NL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BracketsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(STEPParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(STEPParser.RBRACK, 0); }
		public BracketsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_brackets; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterBrackets(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitBrackets(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBrackets(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BracketsContext brackets() {
		BracketsContext _localctx = new BracketsContext(Context, State);
		EnterRule(_localctx, 18, RULE_brackets);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 243;
			Match(LBRACK);
			State = 244;
			Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Params_contentContext params_content() {
			return GetRuleContext<Params_contentContext>(0);
		}
		public ParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_params; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitParams(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamsContext @params() {
		ParamsContext _localctx = new ParamsContext(Context, State);
		EnterRule(_localctx, 20, RULE_params);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 246;
			Match(LPAREN);
			State = 248;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NUMBER) | (1L << STRING) | (1L << BOOLEAN) | (1L << ANALOGPIN) | (1L << DIGITALPIN))) != 0)) {
				{
				State = 247;
				params_content();
				}
			}

			State = 250;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Params_contentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParamstypeContext paramstype() {
			return GetRuleContext<ParamstypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BracketsContext brackets() {
			return GetRuleContext<BracketsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Params_multiContext[] params_multi() {
			return GetRuleContexts<Params_multiContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Params_multiContext params_multi(int i) {
			return GetRuleContext<Params_multiContext>(i);
		}
		public Params_contentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_params_content; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterParams_content(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitParams_content(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParams_content(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Params_contentContext params_content() {
		Params_contentContext _localctx = new Params_contentContext(Context, State);
		EnterRule(_localctx, 22, RULE_params_content);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 252;
			paramstype();
			State = 254;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 253;
				brackets();
				}
			}

			State = 256;
			Match(ID);
			State = 260;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 257;
				params_multi();
				}
				}
				State = 262;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Params_multiContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(STEPParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParamstypeContext paramstype() {
			return GetRuleContext<ParamstypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BracketsContext brackets() {
			return GetRuleContext<BracketsContext>(0);
		}
		public Params_multiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_params_multi; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterParams_multi(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitParams_multi(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParams_multi(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Params_multiContext params_multi() {
		Params_multiContext _localctx = new Params_multiContext(Context, State);
		EnterRule(_localctx, 24, RULE_params_multi);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263;
			Match(COMMA);
			State = 264;
			paramstype();
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 265;
				brackets();
				}
			}

			State = 268;
			Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(STEPParser.NUMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(STEPParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN() { return GetToken(STEPParser.BOOLEAN, 0); }
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 26, RULE_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 270;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NUMBER) | (1L << STRING) | (1L << BOOLEAN))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamstypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PintypeContext pintype() {
			return GetRuleContext<PintypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ParamstypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paramstype; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterParamstype(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitParamstype(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParamstype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamstypeContext paramstype() {
		ParamstypeContext _localctx = new ParamstypeContext(Context, State);
		EnterRule(_localctx, 28, RULE_paramstype);
		try {
			State = 274;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ANALOGPIN:
			case DIGITALPIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 272;
				pintype();
				}
				break;
			case NUMBER:
			case STRING:
			case BOOLEAN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 273;
				type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL() { return GetToken(STEPParser.NL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtsContext stmts() {
			return GetRuleContext<StmtsContext>(0);
		}
		public StmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StmtContext stmt() {
		StmtContext _localctx = new StmtContext(Context, State);
		EnterRule(_localctx, 30, RULE_stmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 277;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 38)) & ~0x3f) == 0 && ((1L << (_la - 38)) & ((1L << (NUMBER - 38)) | (1L << (STRING - 38)) | (1L << (BOOLEAN - 38)) | (1L << (IF - 38)) | (1L << (REPEATWHILE - 38)) | (1L << (REPEATFOR - 38)) | (1L << (RETURN - 38)) | (1L << (CONSTANT - 38)) | (1L << (ID - 38)))) != 0)) {
				{
				State = 276;
				stmts();
				}
			}

			State = 279;
			Match(NL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StmtsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfstmtContext ifstmt() {
			return GetRuleContext<IfstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhilestmtContext whilestmt() {
			return GetRuleContext<WhilestmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForstmtContext forstmt() {
			return GetRuleContext<ForstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VardclContext vardcl() {
			return GetRuleContext<VardclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssstmtContext assstmt() {
			return GetRuleContext<AssstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunccallContext funccall() {
			return GetRuleContext<FunccallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RetstmtContext retstmt() {
			return GetRuleContext<RetstmtContext>(0);
		}
		public StmtsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stmts; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterStmts(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitStmts(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmts(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StmtsContext stmts() {
		StmtsContext _localctx = new StmtsContext(Context, State);
		EnterRule(_localctx, 32, RULE_stmts);
		try {
			State = 288;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 281;
				ifstmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 282;
				whilestmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 283;
				forstmt();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 284;
				vardcl();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 285;
				assstmt();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 286;
				funccall();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 287;
				retstmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_stmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL() { return GetToken(STEPParser.NL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Loop_stmtsContext loop_stmts() {
			return GetRuleContext<Loop_stmtsContext>(0);
		}
		public Loop_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_stmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoop_stmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoop_stmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_stmtContext loop_stmt() {
		Loop_stmtContext _localctx = new Loop_stmtContext(Context, State);
		EnterRule(_localctx, 34, RULE_loop_stmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 291;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 38)) & ~0x3f) == 0 && ((1L << (_la - 38)) & ((1L << (NUMBER - 38)) | (1L << (STRING - 38)) | (1L << (BOOLEAN - 38)) | (1L << (IF - 38)) | (1L << (REPEATWHILE - 38)) | (1L << (REPEATFOR - 38)) | (1L << (RETURN - 38)) | (1L << (CONSTANT - 38)) | (1L << (ID - 38)))) != 0)) {
				{
				State = 290;
				loop_stmts();
				}
			}

			State = 293;
			Match(NL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_stmtsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoopifstmtContext loopifstmt() {
			return GetRuleContext<LoopifstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhilestmtContext whilestmt() {
			return GetRuleContext<WhilestmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForstmtContext forstmt() {
			return GetRuleContext<ForstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VardclContext vardcl() {
			return GetRuleContext<VardclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssstmtContext assstmt() {
			return GetRuleContext<AssstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunccallContext funccall() {
			return GetRuleContext<FunccallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RetstmtContext retstmt() {
			return GetRuleContext<RetstmtContext>(0);
		}
		public Loop_stmtsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_stmts; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoop_stmts(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoop_stmts(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_stmts(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_stmtsContext loop_stmts() {
		Loop_stmtsContext _localctx = new Loop_stmtsContext(Context, State);
		EnterRule(_localctx, 36, RULE_loop_stmts);
		try {
			State = 302;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 295;
				loopifstmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 296;
				whilestmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 297;
				forstmt();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 298;
				vardcl();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 299;
				assstmt();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 300;
				funccall();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 301;
				retstmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopifbodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Loop_stmtContext loop_stmt() {
			return GetRuleContext<Loop_stmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(STEPParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL() { return GetToken(STEPParser.NL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREAK() { return GetToken(STEPParser.BREAK, 0); }
		public LoopifbodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopifbody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoopifbody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoopifbody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopifbody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopifbodyContext loopifbody() {
		LoopifbodyContext _localctx = new LoopifbodyContext(Context, State);
		EnterRule(_localctx, 38, RULE_loopifbody);
		try {
			State = 309;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NL:
			case NUMBER:
			case STRING:
			case BOOLEAN:
			case IF:
			case REPEATWHILE:
			case REPEATFOR:
			case RETURN:
			case CONSTANT:
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 304;
				loop_stmt();
				}
				break;
			case CONTINUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 305;
				Match(CONTINUE);
				State = 306;
				Match(NL);
				}
				break;
			case BREAK:
				EnterOuterAlt(_localctx, 3);
				{
				State = 307;
				Match(BREAK);
				State = 308;
				Match(NL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(STEPParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDIF() { return GetToken(STEPParser.ENDIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseifstmtContext[] elseifstmt() {
			return GetRuleContexts<ElseifstmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseifstmtContext elseifstmt(int i) {
			return GetRuleContext<ElseifstmtContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElsestmtContext elsestmt() {
			return GetRuleContext<ElsestmtContext>(0);
		}
		public IfstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterIfstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitIfstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfstmtContext ifstmt() {
		IfstmtContext _localctx = new IfstmtContext(Context, State);
		EnterRule(_localctx, 40, RULE_ifstmt);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 311;
			Match(IF);
			State = 312;
			Match(LPAREN);
			State = 313;
			logicexpr(0);
			State = 314;
			Match(RPAREN);
			State = 318;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 315;
				stmt();
				}
				}
				State = 320;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 324;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 321;
					elseifstmt();
					}
					} 
				}
				State = 326;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			}
			State = 328;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 327;
				elsestmt();
				}
			}

			State = 330;
			Match(ENDIF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseifstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(STEPParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(STEPParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		public ElseifstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseifstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterElseifstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitElseifstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseifstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseifstmtContext elseifstmt() {
		ElseifstmtContext _localctx = new ElseifstmtContext(Context, State);
		EnterRule(_localctx, 42, RULE_elseifstmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 332;
			Match(ELSE);
			State = 333;
			Match(IF);
			State = 334;
			Match(LPAREN);
			State = 335;
			logicexpr(0);
			State = 336;
			Match(RPAREN);
			State = 340;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 337;
				stmt();
				}
				}
				State = 342;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElsestmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(STEPParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		public ElsestmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsestmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterElsestmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitElsestmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsestmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElsestmtContext elsestmt() {
		ElsestmtContext _localctx = new ElsestmtContext(Context, State);
		EnterRule(_localctx, 44, RULE_elsestmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 343;
			Match(ELSE);
			State = 347;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 344;
				stmt();
				}
				}
				State = 349;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopifstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(STEPParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDIF() { return GetToken(STEPParser.ENDIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LoopifbodyContext[] loopifbody() {
			return GetRuleContexts<LoopifbodyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopifbodyContext loopifbody(int i) {
			return GetRuleContext<LoopifbodyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopelseifstmtContext[] loopelseifstmt() {
			return GetRuleContexts<LoopelseifstmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopelseifstmtContext loopelseifstmt(int i) {
			return GetRuleContext<LoopelseifstmtContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopelsestmtContext loopelsestmt() {
			return GetRuleContext<LoopelsestmtContext>(0);
		}
		public LoopifstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopifstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoopifstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoopifstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopifstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopifstmtContext loopifstmt() {
		LoopifstmtContext _localctx = new LoopifstmtContext(Context, State);
		EnterRule(_localctx, 46, RULE_loopifstmt);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 350;
			Match(IF);
			State = 351;
			Match(LPAREN);
			State = 352;
			logicexpr(0);
			State = 353;
			Match(RPAREN);
			State = 357;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (CONTINUE - 21)) | (1L << (BREAK - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 354;
				loopifbody();
				}
				}
				State = 359;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 363;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 360;
					loopelseifstmt();
					}
					} 
				}
				State = 365;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			}
			State = 367;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 366;
				loopelsestmt();
				}
			}

			State = 369;
			Match(ENDIF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopelseifstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(STEPParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(STEPParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LoopifbodyContext[] loopifbody() {
			return GetRuleContexts<LoopifbodyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopifbodyContext loopifbody(int i) {
			return GetRuleContext<LoopifbodyContext>(i);
		}
		public LoopelseifstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopelseifstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoopelseifstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoopelseifstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopelseifstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopelseifstmtContext loopelseifstmt() {
		LoopelseifstmtContext _localctx = new LoopelseifstmtContext(Context, State);
		EnterRule(_localctx, 48, RULE_loopelseifstmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 371;
			Match(ELSE);
			State = 372;
			Match(IF);
			State = 373;
			Match(LPAREN);
			State = 374;
			logicexpr(0);
			State = 375;
			Match(RPAREN);
			State = 379;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (CONTINUE - 21)) | (1L << (BREAK - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 376;
				loopifbody();
				}
				}
				State = 381;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopelsestmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(STEPParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LoopifbodyContext[] loopifbody() {
			return GetRuleContexts<LoopifbodyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopifbodyContext loopifbody(int i) {
			return GetRuleContext<LoopifbodyContext>(i);
		}
		public LoopelsestmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopelsestmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLoopelsestmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLoopelsestmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopelsestmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopelsestmtContext loopelsestmt() {
		LoopelsestmtContext _localctx = new LoopelsestmtContext(Context, State);
		EnterRule(_localctx, 50, RULE_loopelsestmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 382;
			Match(ELSE);
			State = 386;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (CONTINUE - 21)) | (1L << (BREAK - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 383;
				loopifbody();
				}
				}
				State = 388;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhilestmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPEATWHILE() { return GetToken(STEPParser.REPEATWHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDWHILE() { return GetToken(STEPParser.ENDWHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Loop_stmtContext[] loop_stmt() {
			return GetRuleContexts<Loop_stmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Loop_stmtContext loop_stmt(int i) {
			return GetRuleContext<Loop_stmtContext>(i);
		}
		public WhilestmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whilestmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterWhilestmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitWhilestmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhilestmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhilestmtContext whilestmt() {
		WhilestmtContext _localctx = new WhilestmtContext(Context, State);
		EnterRule(_localctx, 52, RULE_whilestmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 389;
			Match(REPEATWHILE);
			State = 390;
			Match(LPAREN);
			State = 391;
			logicexpr(0);
			State = 392;
			Match(RPAREN);
			State = 396;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 393;
				loop_stmt();
				}
				}
				State = 398;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 399;
			Match(ENDWHILE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPEATFOR() { return GetToken(STEPParser.REPEATFOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public For_iter_optContext for_iter_opt() {
			return GetRuleContext<For_iter_optContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(STEPParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(STEPParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHANGEBY() { return GetToken(STEPParser.CHANGEBY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDFOR() { return GetToken(STEPParser.ENDFOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Loop_stmtContext[] loop_stmt() {
			return GetRuleContexts<Loop_stmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Loop_stmtContext loop_stmt(int i) {
			return GetRuleContext<Loop_stmtContext>(i);
		}
		public ForstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterForstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitForstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForstmtContext forstmt() {
		ForstmtContext _localctx = new ForstmtContext(Context, State);
		EnterRule(_localctx, 54, RULE_forstmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 401;
			Match(REPEATFOR);
			State = 402;
			Match(LPAREN);
			State = 403;
			for_iter_opt();
			State = 404;
			Match(TO);
			State = 405;
			expr(0);
			State = 406;
			Match(COMMA);
			State = 407;
			Match(CHANGEBY);
			State = 408;
			expr(0);
			State = 409;
			Match(RPAREN);
			State = 413;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (NL - 21)) | (1L << (NUMBER - 21)) | (1L << (STRING - 21)) | (1L << (BOOLEAN - 21)) | (1L << (IF - 21)) | (1L << (REPEATWHILE - 21)) | (1L << (REPEATFOR - 21)) | (1L << (RETURN - 21)) | (1L << (CONSTANT - 21)) | (1L << (ID - 21)))) != 0)) {
				{
				{
				State = 410;
				loop_stmt();
				}
				}
				State = 415;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 416;
			Match(ENDFOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_iter_optContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NumdclContext numdcl() {
			return GetRuleContext<NumdclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssstmtContext assstmt() {
			return GetRuleContext<AssstmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArrindexContext arrindex() {
			return GetRuleContext<ArrindexContext>(0);
		}
		public For_iter_optContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_iter_opt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterFor_iter_opt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitFor_iter_opt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_iter_opt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_iter_optContext for_iter_opt() {
		For_iter_optContext _localctx = new For_iter_optContext(Context, State);
		EnterRule(_localctx, 56, RULE_for_iter_opt);
		int _la;
		try {
			State = 424;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,43,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 418;
				numdcl();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 419;
				assstmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 420;
				Match(ID);
				State = 422;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LBRACK) {
					{
					State = 421;
					arrindex();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(STEPParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrindexContext arrindex() {
			return GetRuleContext<ArrindexContext>(0);
		}
		public AssstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterAssstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitAssstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssstmtContext assstmt() {
		AssstmtContext _localctx = new AssstmtContext(Context, State);
		EnterRule(_localctx, 58, RULE_assstmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 426;
			Match(ID);
			State = 428;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 427;
				arrindex();
				}
			}

			State = 430;
			Match(ASSIGN);
			State = 431;
			logicexpr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunccallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Params_optionsContext params_options() {
			return GetRuleContext<Params_optionsContext>(0);
		}
		public FunccallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funccall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterFunccall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitFunccall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunccall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunccallContext funccall() {
		FunccallContext _localctx = new FunccallContext(Context, State);
		EnterRule(_localctx, 60, RULE_funccall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 433;
			Match(ID);
			State = 434;
			Match(LPAREN);
			State = 436;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 4)) & ~0x3f) == 0 && ((1L << (_la - 4)) & ((1L << (LPAREN - 4)) | (1L << (MINUS - 4)) | (1L << (NEG - 4)) | (1L << (INTLITERAL - 4)) | (1L << (NUMLITERAL - 4)) | (1L << (STRLITERAL - 4)) | (1L << (BOOLLITERAL - 4)) | (1L << (ID - 4)))) != 0)) {
				{
				State = 435;
				params_options();
				}
			}

			State = 438;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Params_optionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Multi_exprContext[] multi_expr() {
			return GetRuleContexts<Multi_exprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Multi_exprContext multi_expr(int i) {
			return GetRuleContext<Multi_exprContext>(i);
		}
		public Params_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_params_options; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterParams_options(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitParams_options(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParams_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Params_optionsContext params_options() {
		Params_optionsContext _localctx = new Params_optionsContext(Context, State);
		EnterRule(_localctx, 62, RULE_params_options);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 440;
			logicexpr(0);
			State = 444;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 441;
				multi_expr();
				}
				}
				State = 446;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_exprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(STEPParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		public Multi_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_expr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterMulti_expr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitMulti_expr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_exprContext multi_expr() {
		Multi_exprContext _localctx = new Multi_exprContext(Context, State);
		EnterRule(_localctx, 64, RULE_multi_expr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 447;
			Match(COMMA);
			State = 448;
			logicexpr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RetstmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(STEPParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		public RetstmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_retstmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterRetstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitRetstmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRetstmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RetstmtContext retstmt() {
		RetstmtContext _localctx = new RetstmtContext(Context, State);
		EnterRule(_localctx, 66, RULE_retstmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 450;
			Match(RETURN);
			State = 452;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 4)) & ~0x3f) == 0 && ((1L << (_la - 4)) & ((1L << (LPAREN - 4)) | (1L << (MINUS - 4)) | (1L << (NEG - 4)) | (1L << (INTLITERAL - 4)) | (1L << (NUMLITERAL - 4)) | (1L << (STRLITERAL - 4)) | (1L << (BOOLLITERAL - 4)) | (1L << (ID - 4)))) != 0)) {
				{
				State = 451;
				logicexpr(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrindexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(STEPParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(STEPParser.RBRACK, 0); }
		public ArrindexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrindex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterArrindex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitArrindex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrindex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrindexContext arrindex() {
		ArrindexContext _localctx = new ArrindexContext(Context, State);
		EnterRule(_localctx, 68, RULE_arrindex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 454;
			Match(LBRACK);
			State = 455;
			expr(0);
			State = 456;
			Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(STEPParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(STEPParser.MINUS, 0); }
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		return expr(0);
	}

	private ExprContext expr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExprContext _localctx = new ExprContext(Context, _parentState);
		ExprContext _prevctx = _localctx;
		int _startState = 70;
		EnterRecursionRule(_localctx, 70, RULE_expr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 459;
			term(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 469;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 467;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
					case 1:
						{
						_localctx = new ExprContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 461;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 462;
						Match(PLUS);
						State = 463;
						term(0);
						}
						break;
					case 2:
						{
						_localctx = new ExprContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 464;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 465;
						Match(MINUS);
						State = 466;
						term(0);
						}
						break;
					}
					} 
				}
				State = 471;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TermContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FactorContext factor() {
			return GetRuleContext<FactorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULT() { return GetToken(STEPParser.MULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIVIDE() { return GetToken(STEPParser.DIVIDE, 0); }
		public TermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_term; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TermContext term() {
		return term(0);
	}

	private TermContext term(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TermContext _localctx = new TermContext(Context, _parentState);
		TermContext _prevctx = _localctx;
		int _startState = 72;
		EnterRecursionRule(_localctx, 72, RULE_term, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 473;
			factor(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 483;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,51,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 481;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
					case 1:
						{
						_localctx = new TermContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_term);
						State = 475;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 476;
						Match(MULT);
						State = 477;
						factor(0);
						}
						break;
					case 2:
						{
						_localctx = new TermContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_term);
						State = 478;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 479;
						Match(DIVIDE);
						State = 480;
						factor(0);
						}
						break;
					}
					} 
				}
				State = 485;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,51,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class FactorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FactorContext factor() {
			return GetRuleContext<FactorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POW() { return GetToken(STEPParser.POW, 0); }
		public FactorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factor; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterFactor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitFactor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFactor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FactorContext factor() {
		return factor(0);
	}

	private FactorContext factor(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		FactorContext _localctx = new FactorContext(Context, _parentState);
		FactorContext _prevctx = _localctx;
		int _startState = 74;
		EnterRecursionRule(_localctx, 74, RULE_factor, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 487;
			value();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 494;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,52,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new FactorContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_factor);
					State = 489;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 490;
					Match(POW);
					State = 491;
					value();
					}
					} 
				}
				State = 496;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,52,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(STEPParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(STEPParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunccallContext funccall() {
			return GetRuleContext<FunccallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(STEPParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArrindexContext arrindex() {
			return GetRuleContext<ArrindexContext>(0);
		}
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(Context, State);
		EnterRule(_localctx, 76, RULE_value);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 498;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUS) {
				{
				State = 497;
				Match(MINUS);
				}
			}

			State = 510;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,55,Context) ) {
			case 1:
				{
				State = 500;
				constant();
				}
				break;
			case 2:
				{
				State = 501;
				Match(ID);
				State = 503;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,54,Context) ) {
				case 1:
					{
					State = 502;
					arrindex();
					}
					break;
				}
				}
				break;
			case 3:
				{
				State = 505;
				Match(LPAREN);
				State = 506;
				logicexpr(0);
				State = 507;
				Match(RPAREN);
				}
				break;
			case 4:
				{
				State = 509;
				funccall();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMLITERAL() { return GetToken(STEPParser.NUMLITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTLITERAL() { return GetToken(STEPParser.INTLITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRLITERAL() { return GetToken(STEPParser.STRLITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLLITERAL() { return GetToken(STEPParser.BOOLLITERAL, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 78, RULE_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 512;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTLITERAL) | (1L << NUMLITERAL) | (1L << STRLITERAL) | (1L << BOOLLITERAL))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicexprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicequalContext logicequal() {
			return GetRuleContext<LogicequalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(STEPParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(STEPParser.OR, 0); }
		public LogicexprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicexpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLogicexpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLogicexpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicexpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicexprContext logicexpr() {
		return logicexpr(0);
	}

	private LogicexprContext logicexpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicexprContext _localctx = new LogicexprContext(Context, _parentState);
		LogicexprContext _prevctx = _localctx;
		int _startState = 80;
		EnterRecursionRule(_localctx, 80, RULE_logicexpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 515;
			logicequal();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 525;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,57,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 523;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,56,Context) ) {
					case 1:
						{
						_localctx = new LogicexprContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_logicexpr);
						State = 517;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 518;
						Match(AND);
						State = 519;
						logicequal();
						}
						break;
					case 2:
						{
						_localctx = new LogicexprContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_logicexpr);
						State = 520;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 521;
						Match(OR);
						State = 522;
						logicequal();
						}
						break;
					}
					} 
				}
				State = 527;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,57,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LogicequalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogiccompContext[] logiccomp() {
			return GetRuleContexts<LogiccompContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogiccompContext logiccomp(int i) {
			return GetRuleContext<LogiccompContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(STEPParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEQ() { return GetToken(STEPParser.NEQ, 0); }
		public LogicequalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicequal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLogicequal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLogicequal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicequal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicequalContext logicequal() {
		LogicequalContext _localctx = new LogicequalContext(Context, State);
		EnterRule(_localctx, 82, RULE_logicequal);
		try {
			State = 537;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 528;
				logiccomp();
				State = 529;
				Match(EQ);
				State = 530;
				logiccomp();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 532;
				logiccomp();
				State = 533;
				Match(NEQ);
				State = 534;
				logiccomp();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 536;
				logiccomp();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogiccompContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicvalueContext[] logicvalue() {
			return GetRuleContexts<LogicvalueContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicvalueContext logicvalue(int i) {
			return GetRuleContext<LogicvalueContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogiccompopContext logiccompop() {
			return GetRuleContext<LogiccompopContext>(0);
		}
		public LogiccompContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logiccomp; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLogiccomp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLogiccomp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogiccomp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogiccompContext logiccomp() {
		LogiccompContext _localctx = new LogiccompContext(Context, State);
		EnterRule(_localctx, 84, RULE_logiccomp);
		try {
			State = 544;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 539;
				logicvalue();
				State = 540;
				logiccompop();
				State = 541;
				logicvalue();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 543;
				logicvalue();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogiccompopContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRTHANEQ() { return GetToken(STEPParser.GRTHANEQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRTHAN() { return GetToken(STEPParser.GRTHAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LTHANEQ() { return GetToken(STEPParser.LTHANEQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LTHAN() { return GetToken(STEPParser.LTHAN, 0); }
		public LogiccompopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logiccompop; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLogiccompop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLogiccompop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogiccompop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogiccompopContext logiccompop() {
		LogiccompopContext _localctx = new LogiccompopContext(Context, State);
		EnterRule(_localctx, 86, RULE_logiccompop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 546;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GRTHAN) | (1L << GRTHANEQ) | (1L << LTHAN) | (1L << LTHANEQ))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicvalueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEG() { return GetToken(STEPParser.NEG, 0); }
		public LogicvalueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicvalue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterLogicvalue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitLogicvalue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicvalue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicvalueContext logicvalue() {
		LogicvalueContext _localctx = new LogicvalueContext(Context, State);
		EnterRule(_localctx, 88, RULE_logicvalue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 549;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NEG) {
				{
				State = 548;
				Match(NEG);
				}
			}

			State = 551;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VardclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Var_optionsContext var_options() {
			return GetRuleContext<Var_optionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(STEPParser.CONSTANT, 0); }
		public VardclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vardcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterVardcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitVardcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VardclContext vardcl() {
		VardclContext _localctx = new VardclContext(Context, State);
		EnterRule(_localctx, 90, RULE_vardcl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 554;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTANT) {
				{
				State = 553;
				Match(CONSTANT);
				}
			}

			State = 556;
			var_options();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Var_optionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NumdclContext numdcl() {
			return GetRuleContext<NumdclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringdclContext stringdcl() {
			return GetRuleContext<StringdclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooldclContext booldcl() {
			return GetRuleContext<BooldclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrdclContext arrdcl() {
			return GetRuleContext<ArrdclContext>(0);
		}
		public Var_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_var_options; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterVar_options(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitVar_options(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVar_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Var_optionsContext var_options() {
		Var_optionsContext _localctx = new Var_optionsContext(Context, State);
		EnterRule(_localctx, 92, RULE_var_options);
		try {
			State = 562;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 558;
				numdcl();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 559;
				stringdcl();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 560;
				booldcl();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 561;
				arrdcl();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumdclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(STEPParser.NUMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(STEPParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public NumdclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numdcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterNumdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitNumdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumdcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumdclContext numdcl() {
		NumdclContext _localctx = new NumdclContext(Context, State);
		EnterRule(_localctx, 94, RULE_numdcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 564;
			Match(NUMBER);
			State = 565;
			Match(ID);
			State = 566;
			Match(ASSIGN);
			State = 567;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringdclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(STEPParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(STEPParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public StringdclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringdcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterStringdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitStringdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringdcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringdclContext stringdcl() {
		StringdclContext _localctx = new StringdclContext(Context, State);
		EnterRule(_localctx, 96, RULE_stringdcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 569;
			Match(STRING);
			State = 570;
			Match(ID);
			State = 571;
			Match(ASSIGN);
			State = 572;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooldclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN() { return GetToken(STEPParser.BOOLEAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(STEPParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicexprContext logicexpr() {
			return GetRuleContext<LogicexprContext>(0);
		}
		public BooldclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booldcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterBooldcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitBooldcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooldcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooldclContext booldcl() {
		BooldclContext _localctx = new BooldclContext(Context, State);
		EnterRule(_localctx, 98, RULE_booldcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 574;
			Match(BOOLEAN);
			State = 575;
			Match(ID);
			State = 576;
			Match(ASSIGN);
			State = 577;
			logicexpr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PindclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PinmodeContext pinmode() {
			return GetRuleContext<PinmodeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PintypeContext pintype() {
			return GetRuleContext<PintypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(STEPParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTLITERAL() { return GetToken(STEPParser.INTLITERAL, 0); }
		public PindclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pindcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterPindcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitPindcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPindcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PindclContext pindcl() {
		PindclContext _localctx = new PindclContext(Context, State);
		EnterRule(_localctx, 100, RULE_pindcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 579;
			pinmode();
			State = 580;
			pintype();
			State = 581;
			Match(ID);
			State = 582;
			Match(ASSIGN);
			State = 583;
			Match(INTLITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PinmodeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INPUT() { return GetToken(STEPParser.INPUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUTPUT() { return GetToken(STEPParser.OUTPUT, 0); }
		public PinmodeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pinmode; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterPinmode(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitPinmode(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPinmode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PinmodeContext pinmode() {
		PinmodeContext _localctx = new PinmodeContext(Context, State);
		EnterRule(_localctx, 102, RULE_pinmode);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 585;
			_la = TokenStream.LA(1);
			if ( !(_la==INPUT || _la==OUTPUT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PintypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANALOGPIN() { return GetToken(STEPParser.ANALOGPIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIGITALPIN() { return GetToken(STEPParser.DIGITALPIN, 0); }
		public PintypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pintype; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterPintype(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitPintype(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPintype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PintypeContext pintype() {
		PintypeContext _localctx = new PintypeContext(Context, State);
		EnterRule(_localctx, 104, RULE_pintype);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 587;
			_la = TokenStream.LA(1);
			if ( !(_la==ANALOGPIN || _la==DIGITALPIN) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrdclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrsizedclContext arrsizedcl() {
			return GetRuleContext<ArrsizedclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(STEPParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Arr_id_or_litContext arr_id_or_lit() {
			return GetRuleContext<Arr_id_or_litContext>(0);
		}
		public ArrdclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrdcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterArrdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitArrdcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrdcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrdclContext arrdcl() {
		ArrdclContext _localctx = new ArrdclContext(Context, State);
		EnterRule(_localctx, 106, RULE_arrdcl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 589;
			type();
			State = 590;
			arrsizedcl();
			State = 591;
			Match(ID);
			State = 594;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASSIGN) {
				{
				State = 592;
				Match(ASSIGN);
				State = 593;
				arr_id_or_lit();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Arr_id_or_litContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(STEPParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(STEPParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(STEPParser.RBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Params_optionsContext params_options() {
			return GetRuleContext<Params_optionsContext>(0);
		}
		public Arr_id_or_litContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arr_id_or_lit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterArr_id_or_lit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitArr_id_or_lit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArr_id_or_lit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Arr_id_or_litContext arr_id_or_lit() {
		Arr_id_or_litContext _localctx = new Arr_id_or_litContext(Context, State);
		EnterRule(_localctx, 108, RULE_arr_id_or_lit);
		int _la;
		try {
			State = 602;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 596;
				Match(ID);
				}
				break;
			case LBRACK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 597;
				Match(LBRACK);
				State = 599;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 4)) & ~0x3f) == 0 && ((1L << (_la - 4)) & ((1L << (LPAREN - 4)) | (1L << (MINUS - 4)) | (1L << (NEG - 4)) | (1L << (INTLITERAL - 4)) | (1L << (NUMLITERAL - 4)) | (1L << (STRLITERAL - 4)) | (1L << (BOOLLITERAL - 4)) | (1L << (ID - 4)))) != 0)) {
					{
					State = 598;
					params_options();
					}
				}

				State = 601;
				Match(RBRACK);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrsizedclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(STEPParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTLITERAL() { return GetToken(STEPParser.INTLITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(STEPParser.RBRACK, 0); }
		public ArrsizedclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrsizedcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.EnterArrsizedcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISTEPListener typedListener = listener as ISTEPListener;
			if (typedListener != null) typedListener.ExitArrsizedcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISTEPVisitor<TResult> typedVisitor = visitor as ISTEPVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrsizedcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrsizedclContext arrsizedcl() {
		ArrsizedclContext _localctx = new ArrsizedclContext(Context, State);
		EnterRule(_localctx, 110, RULE_arrsizedcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 604;
			Match(LBRACK);
			State = 605;
			Match(INTLITERAL);
			State = 606;
			Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 35: return expr_sempred((ExprContext)_localctx, predIndex);
		case 36: return term_sempred((TermContext)_localctx, predIndex);
		case 37: return factor_sempred((FactorContext)_localctx, predIndex);
		case 40: return logicexpr_sempred((LogicexprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expr_sempred(ExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 3);
		case 1: return Precpred(Context, 2);
		}
		return true;
	}
	private bool term_sempred(TermContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 3);
		case 3: return Precpred(Context, 2);
		}
		return true;
	}
	private bool factor_sempred(FactorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 2);
		}
		return true;
	}
	private bool logicexpr_sempred(LogicexprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(Context, 3);
		case 6: return Precpred(Context, 2);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x44', '\x263', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x3', '\x2', '\a', '\x2', 't', '\n', '\x2', '\f', '\x2', '\xE', '\x2', 
		'w', '\v', '\x2', '\x3', '\x2', '\x5', '\x2', 'z', '\n', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x5', '\x2', '~', '\n', '\x2', '\x3', '\x3', '\x3', 
		'\x3', '\a', '\x3', '\x82', '\n', '\x3', '\f', '\x3', '\xE', '\x3', '\x85', 
		'\v', '\x3', '\x3', '\x3', '\x3', '\x3', '\a', '\x3', '\x89', '\n', '\x3', 
		'\f', '\x3', '\xE', '\x3', '\x8C', '\v', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\a', '\x3', '\x90', '\n', '\x3', '\f', '\x3', '\xE', '\x3', '\x93', '\v', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\a', '\x3', '\x97', '\n', '\x3', '\f', 
		'\x3', '\xE', '\x3', '\x9A', '\v', '\x3', '\x5', '\x3', '\x9C', '\n', 
		'\x3', '\x3', '\x4', '\x3', '\x4', '\a', '\x4', '\xA0', '\n', '\x4', '\f', 
		'\x4', '\xE', '\x4', '\xA3', '\v', '\x4', '\x3', '\x4', '\x3', '\x4', 
		'\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\xA9', '\n', '\x5', '\f', '\x5', 
		'\xE', '\x5', '\xAC', '\v', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', 
		'\x6', '\x3', '\x6', '\a', '\x6', '\xB2', '\n', '\x6', '\f', '\x6', '\xE', 
		'\x6', '\xB5', '\v', '\x6', '\x3', '\x6', '\x3', '\x6', '\a', '\x6', '\xB9', 
		'\n', '\x6', '\f', '\x6', '\xE', '\x6', '\xBC', '\v', '\x6', '\x3', '\a', 
		'\x3', '\a', '\x3', '\a', '\x5', '\a', '\xC1', '\n', '\a', '\x3', '\b', 
		'\x3', '\b', '\a', '\b', '\xC5', '\n', '\b', '\f', '\b', '\xE', '\b', 
		'\xC8', '\v', '\b', '\x3', '\b', '\x3', '\b', '\a', '\b', '\xCC', '\n', 
		'\b', '\f', '\b', '\xE', '\b', '\xCF', '\v', '\b', '\x3', '\t', '\x3', 
		'\t', '\x5', '\t', '\xD3', '\n', '\t', '\x3', '\t', '\x3', '\t', '\x3', 
		'\t', '\x3', '\t', '\a', '\t', '\xD9', '\n', '\t', '\f', '\t', '\xE', 
		'\t', '\xDC', '\v', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', 
		'\x3', '\t', '\a', '\t', '\xE8', '\n', '\t', '\f', '\t', '\xE', '\t', 
		'\xEB', '\v', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', 
		'\xF0', '\n', '\t', '\x3', '\n', '\x3', '\n', '\x5', '\n', '\xF4', '\n', 
		'\n', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', 
		'\x5', '\f', '\xFB', '\n', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\r', 
		'\x3', '\r', '\x5', '\r', '\x101', '\n', '\r', '\x3', '\r', '\x3', '\r', 
		'\a', '\r', '\x105', '\n', '\r', '\f', '\r', '\xE', '\r', '\x108', '\v', 
		'\r', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x10D', 
		'\n', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\x10', '\x3', '\x10', '\x5', '\x10', '\x115', '\n', '\x10', '\x3', '\x11', 
		'\x5', '\x11', '\x118', '\n', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x5', '\x12', '\x123', '\n', '\x12', '\x3', '\x13', 
		'\x5', '\x13', '\x126', '\n', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x5', '\x14', '\x131', '\n', '\x14', '\x3', '\x15', 
		'\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x5', '\x15', 
		'\x138', '\n', '\x15', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\a', '\x16', '\x13F', '\n', '\x16', '\f', '\x16', 
		'\xE', '\x16', '\x142', '\v', '\x16', '\x3', '\x16', '\a', '\x16', '\x145', 
		'\n', '\x16', '\f', '\x16', '\xE', '\x16', '\x148', '\v', '\x16', '\x3', 
		'\x16', '\x5', '\x16', '\x14B', '\n', '\x16', '\x3', '\x16', '\x3', '\x16', 
		'\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', 
		'\x3', '\x17', '\a', '\x17', '\x155', '\n', '\x17', '\f', '\x17', '\xE', 
		'\x17', '\x158', '\v', '\x17', '\x3', '\x18', '\x3', '\x18', '\a', '\x18', 
		'\x15C', '\n', '\x18', '\f', '\x18', '\xE', '\x18', '\x15F', '\v', '\x18', 
		'\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', 
		'\a', '\x19', '\x166', '\n', '\x19', '\f', '\x19', '\xE', '\x19', '\x169', 
		'\v', '\x19', '\x3', '\x19', '\a', '\x19', '\x16C', '\n', '\x19', '\f', 
		'\x19', '\xE', '\x19', '\x16F', '\v', '\x19', '\x3', '\x19', '\x5', '\x19', 
		'\x172', '\n', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x1A', '\x3', 
		'\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\a', 
		'\x1A', '\x17C', '\n', '\x1A', '\f', '\x1A', '\xE', '\x1A', '\x17F', '\v', 
		'\x1A', '\x3', '\x1B', '\x3', '\x1B', '\a', '\x1B', '\x183', '\n', '\x1B', 
		'\f', '\x1B', '\xE', '\x1B', '\x186', '\v', '\x1B', '\x3', '\x1C', '\x3', 
		'\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\a', '\x1C', '\x18D', 
		'\n', '\x1C', '\f', '\x1C', '\xE', '\x1C', '\x190', '\v', '\x1C', '\x3', 
		'\x1C', '\x3', '\x1C', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1D', '\x3', '\x1D', '\a', '\x1D', '\x19E', '\n', '\x1D', '\f', '\x1D', 
		'\xE', '\x1D', '\x1A1', '\v', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x5', '\x1E', '\x1A9', 
		'\n', '\x1E', '\x5', '\x1E', '\x1AB', '\n', '\x1E', '\x3', '\x1F', '\x3', 
		'\x1F', '\x5', '\x1F', '\x1AF', '\n', '\x1F', '\x3', '\x1F', '\x3', '\x1F', 
		'\x3', '\x1F', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\x5', ' ', '\x1B7', 
		'\n', ' ', '\x3', ' ', '\x3', ' ', '\x3', '!', '\x3', '!', '\a', '!', 
		'\x1BD', '\n', '!', '\f', '!', '\xE', '!', '\x1C0', '\v', '!', '\x3', 
		'\"', '\x3', '\"', '\x3', '\"', '\x3', '#', '\x3', '#', '\x5', '#', '\x1C7', 
		'\n', '#', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\a', '%', '\x1D6', '\n', '%', '\f', '%', '\xE', 
		'%', '\x1D9', '\v', '%', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', 
		'\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\a', '&', 
		'\x1E4', '\n', '&', '\f', '&', '\xE', '&', '\x1E7', '\v', '&', '\x3', 
		'\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', 
		'\a', '\'', '\x1EF', '\n', '\'', '\f', '\'', '\xE', '\'', '\x1F2', '\v', 
		'\'', '\x3', '(', '\x5', '(', '\x1F5', '\n', '(', '\x3', '(', '\x3', '(', 
		'\x3', '(', '\x5', '(', '\x1FA', '\n', '(', '\x3', '(', '\x3', '(', '\x3', 
		'(', '\x3', '(', '\x3', '(', '\x5', '(', '\x201', '\n', '(', '\x3', ')', 
		'\x3', ')', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', 
		'\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\a', '*', '\x20E', '\n', 
		'*', '\f', '*', '\xE', '*', '\x211', '\v', '*', '\x3', '+', '\x3', '+', 
		'\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', 
		'\x3', '+', '\x5', '+', '\x21C', '\n', '+', '\x3', ',', '\x3', ',', '\x3', 
		',', '\x3', ',', '\x3', ',', '\x5', ',', '\x223', '\n', ',', '\x3', '-', 
		'\x3', '-', '\x3', '.', '\x5', '.', '\x228', '\n', '.', '\x3', '.', '\x3', 
		'.', '\x3', '/', '\x5', '/', '\x22D', '\n', '/', '\x3', '/', '\x3', '/', 
		'\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', 
		'\x235', '\n', '\x30', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x3', 
		'\x31', '\x3', '\x31', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', 
		'\x32', '\x3', '\x32', '\x3', '\x33', '\x3', '\x33', '\x3', '\x33', '\x3', 
		'\x33', '\x3', '\x33', '\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', 
		'\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x35', '\x3', '\x35', '\x3', 
		'\x36', '\x3', '\x36', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', '\x3', 
		'\x37', '\x3', '\x37', '\x5', '\x37', '\x255', '\n', '\x37', '\x3', '\x38', 
		'\x3', '\x38', '\x3', '\x38', '\x5', '\x38', '\x25A', '\n', '\x38', '\x3', 
		'\x38', '\x5', '\x38', '\x25D', '\n', '\x38', '\x3', '\x39', '\x3', '\x39', 
		'\x3', '\x39', '\x3', '\x39', '\x3', '\x39', '\x2', '\x6', 'H', 'J', 'L', 
		'R', ':', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', 
		'\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', 
		'*', ',', '.', '\x30', '\x32', '\x34', '\x36', '\x38', ':', '<', '>', 
		'@', '\x42', '\x44', '\x46', 'H', 'J', 'L', 'N', 'P', 'R', 'T', 'V', 'X', 
		'Z', '\\', '^', '`', '\x62', '\x64', '\x66', 'h', 'j', 'l', 'n', 'p', 
		'\x2', '\a', '\x3', '\x2', '(', '*', '\x3', '\x2', '\x19', '\x1C', '\x3', 
		'\x2', '\x10', '\x13', '\x3', '\x2', '\x42', '\x43', '\x3', '\x2', '+', 
		',', '\x2', '\x27F', '\x2', 'u', '\x3', '\x2', '\x2', '\x2', '\x4', '\x9B', 
		'\x3', '\x2', '\x2', '\x2', '\x6', '\x9D', '\x3', '\x2', '\x2', '\x2', 
		'\b', '\xA6', '\x3', '\x2', '\x2', '\x2', '\n', '\xAF', '\x3', '\x2', 
		'\x2', '\x2', '\f', '\xC0', '\x3', '\x2', '\x2', '\x2', '\xE', '\xC2', 
		'\x3', '\x2', '\x2', '\x2', '\x10', '\xEF', '\x3', '\x2', '\x2', '\x2', 
		'\x12', '\xF3', '\x3', '\x2', '\x2', '\x2', '\x14', '\xF5', '\x3', '\x2', 
		'\x2', '\x2', '\x16', '\xF8', '\x3', '\x2', '\x2', '\x2', '\x18', '\xFE', 
		'\x3', '\x2', '\x2', '\x2', '\x1A', '\x109', '\x3', '\x2', '\x2', '\x2', 
		'\x1C', '\x110', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x114', '\x3', '\x2', 
		'\x2', '\x2', ' ', '\x117', '\x3', '\x2', '\x2', '\x2', '\"', '\x122', 
		'\x3', '\x2', '\x2', '\x2', '$', '\x125', '\x3', '\x2', '\x2', '\x2', 
		'&', '\x130', '\x3', '\x2', '\x2', '\x2', '(', '\x137', '\x3', '\x2', 
		'\x2', '\x2', '*', '\x139', '\x3', '\x2', '\x2', '\x2', ',', '\x14E', 
		'\x3', '\x2', '\x2', '\x2', '.', '\x159', '\x3', '\x2', '\x2', '\x2', 
		'\x30', '\x160', '\x3', '\x2', '\x2', '\x2', '\x32', '\x175', '\x3', '\x2', 
		'\x2', '\x2', '\x34', '\x180', '\x3', '\x2', '\x2', '\x2', '\x36', '\x187', 
		'\x3', '\x2', '\x2', '\x2', '\x38', '\x193', '\x3', '\x2', '\x2', '\x2', 
		':', '\x1AA', '\x3', '\x2', '\x2', '\x2', '<', '\x1AC', '\x3', '\x2', 
		'\x2', '\x2', '>', '\x1B3', '\x3', '\x2', '\x2', '\x2', '@', '\x1BA', 
		'\x3', '\x2', '\x2', '\x2', '\x42', '\x1C1', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x1C4', '\x3', '\x2', '\x2', '\x2', '\x46', '\x1C8', '\x3', '\x2', 
		'\x2', '\x2', 'H', '\x1CC', '\x3', '\x2', '\x2', '\x2', 'J', '\x1DA', 
		'\x3', '\x2', '\x2', '\x2', 'L', '\x1E8', '\x3', '\x2', '\x2', '\x2', 
		'N', '\x1F4', '\x3', '\x2', '\x2', '\x2', 'P', '\x202', '\x3', '\x2', 
		'\x2', '\x2', 'R', '\x204', '\x3', '\x2', '\x2', '\x2', 'T', '\x21B', 
		'\x3', '\x2', '\x2', '\x2', 'V', '\x222', '\x3', '\x2', '\x2', '\x2', 
		'X', '\x224', '\x3', '\x2', '\x2', '\x2', 'Z', '\x227', '\x3', '\x2', 
		'\x2', '\x2', '\\', '\x22C', '\x3', '\x2', '\x2', '\x2', '^', '\x234', 
		'\x3', '\x2', '\x2', '\x2', '`', '\x236', '\x3', '\x2', '\x2', '\x2', 
		'\x62', '\x23B', '\x3', '\x2', '\x2', '\x2', '\x64', '\x240', '\x3', '\x2', 
		'\x2', '\x2', '\x66', '\x245', '\x3', '\x2', '\x2', '\x2', 'h', '\x24B', 
		'\x3', '\x2', '\x2', '\x2', 'j', '\x24D', '\x3', '\x2', '\x2', '\x2', 
		'l', '\x24F', '\x3', '\x2', '\x2', '\x2', 'n', '\x25C', '\x3', '\x2', 
		'\x2', '\x2', 'p', '\x25E', '\x3', '\x2', '\x2', '\x2', 'r', 't', '\a', 
		'\x17', '\x2', '\x2', 's', 'r', '\x3', '\x2', '\x2', '\x2', 't', 'w', 
		'\x3', '\x2', '\x2', '\x2', 'u', 's', '\x3', '\x2', '\x2', '\x2', 'u', 
		'v', '\x3', '\x2', '\x2', '\x2', 'v', 'y', '\x3', '\x2', '\x2', '\x2', 
		'w', 'u', '\x3', '\x2', '\x2', '\x2', 'x', 'z', '\x5', '\n', '\x6', '\x2', 
		'y', 'x', '\x3', '\x2', '\x2', '\x2', 'y', 'z', '\x3', '\x2', '\x2', '\x2', 
		'z', '{', '\x3', '\x2', '\x2', '\x2', '{', '}', '\x5', '\x4', '\x3', '\x2', 
		'|', '~', '\x5', '\xE', '\b', '\x2', '}', '|', '\x3', '\x2', '\x2', '\x2', 
		'}', '~', '\x3', '\x2', '\x2', '\x2', '~', '\x3', '\x3', '\x2', '\x2', 
		'\x2', '\x7F', '\x83', '\x5', '\x6', '\x4', '\x2', '\x80', '\x82', '\a', 
		'\x17', '\x2', '\x2', '\x81', '\x80', '\x3', '\x2', '\x2', '\x2', '\x82', 
		'\x85', '\x3', '\x2', '\x2', '\x2', '\x83', '\x81', '\x3', '\x2', '\x2', 
		'\x2', '\x83', '\x84', '\x3', '\x2', '\x2', '\x2', '\x84', '\x9C', '\x3', 
		'\x2', '\x2', '\x2', '\x85', '\x83', '\x3', '\x2', '\x2', '\x2', '\x86', 
		'\x8A', '\x5', '\b', '\x5', '\x2', '\x87', '\x89', '\a', '\x17', '\x2', 
		'\x2', '\x88', '\x87', '\x3', '\x2', '\x2', '\x2', '\x89', '\x8C', '\x3', 
		'\x2', '\x2', '\x2', '\x8A', '\x88', '\x3', '\x2', '\x2', '\x2', '\x8A', 
		'\x8B', '\x3', '\x2', '\x2', '\x2', '\x8B', '\x9C', '\x3', '\x2', '\x2', 
		'\x2', '\x8C', '\x8A', '\x3', '\x2', '\x2', '\x2', '\x8D', '\x91', '\x5', 
		'\x6', '\x4', '\x2', '\x8E', '\x90', '\a', '\x17', '\x2', '\x2', '\x8F', 
		'\x8E', '\x3', '\x2', '\x2', '\x2', '\x90', '\x93', '\x3', '\x2', '\x2', 
		'\x2', '\x91', '\x8F', '\x3', '\x2', '\x2', '\x2', '\x91', '\x92', '\x3', 
		'\x2', '\x2', '\x2', '\x92', '\x94', '\x3', '\x2', '\x2', '\x2', '\x93', 
		'\x91', '\x3', '\x2', '\x2', '\x2', '\x94', '\x98', '\x5', '\b', '\x5', 
		'\x2', '\x95', '\x97', '\a', '\x17', '\x2', '\x2', '\x96', '\x95', '\x3', 
		'\x2', '\x2', '\x2', '\x97', '\x9A', '\x3', '\x2', '\x2', '\x2', '\x98', 
		'\x96', '\x3', '\x2', '\x2', '\x2', '\x98', '\x99', '\x3', '\x2', '\x2', 
		'\x2', '\x99', '\x9C', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x98', '\x3', 
		'\x2', '\x2', '\x2', '\x9B', '\x7F', '\x3', '\x2', '\x2', '\x2', '\x9B', 
		'\x86', '\x3', '\x2', '\x2', '\x2', '\x9B', '\x8D', '\x3', '\x2', '\x2', 
		'\x2', '\x9C', '\x5', '\x3', '\x2', '\x2', '\x2', '\x9D', '\xA1', '\a', 
		'\x1D', '\x2', '\x2', '\x9E', '\xA0', '\x5', ' ', '\x11', '\x2', '\x9F', 
		'\x9E', '\x3', '\x2', '\x2', '\x2', '\xA0', '\xA3', '\x3', '\x2', '\x2', 
		'\x2', '\xA1', '\x9F', '\x3', '\x2', '\x2', '\x2', '\xA1', '\xA2', '\x3', 
		'\x2', '\x2', '\x2', '\xA2', '\xA4', '\x3', '\x2', '\x2', '\x2', '\xA3', 
		'\xA1', '\x3', '\x2', '\x2', '\x2', '\xA4', '\xA5', '\a', '\x1E', '\x2', 
		'\x2', '\xA5', '\a', '\x3', '\x2', '\x2', '\x2', '\xA6', '\xAA', '\a', 
		'\x1F', '\x2', '\x2', '\xA7', '\xA9', '\x5', ' ', '\x11', '\x2', '\xA8', 
		'\xA7', '\x3', '\x2', '\x2', '\x2', '\xA9', '\xAC', '\x3', '\x2', '\x2', 
		'\x2', '\xAA', '\xA8', '\x3', '\x2', '\x2', '\x2', '\xAA', '\xAB', '\x3', 
		'\x2', '\x2', '\x2', '\xAB', '\xAD', '\x3', '\x2', '\x2', '\x2', '\xAC', 
		'\xAA', '\x3', '\x2', '\x2', '\x2', '\xAD', '\xAE', '\a', ' ', '\x2', 
		'\x2', '\xAE', '\t', '\x3', '\x2', '\x2', '\x2', '\xAF', '\xB3', '\a', 
		'%', '\x2', '\x2', '\xB0', '\xB2', '\x5', '\f', '\a', '\x2', '\xB1', '\xB0', 
		'\x3', '\x2', '\x2', '\x2', '\xB2', '\xB5', '\x3', '\x2', '\x2', '\x2', 
		'\xB3', '\xB1', '\x3', '\x2', '\x2', '\x2', '\xB3', '\xB4', '\x3', '\x2', 
		'\x2', '\x2', '\xB4', '\xB6', '\x3', '\x2', '\x2', '\x2', '\xB5', '\xB3', 
		'\x3', '\x2', '\x2', '\x2', '\xB6', '\xBA', '\a', '&', '\x2', '\x2', '\xB7', 
		'\xB9', '\a', '\x17', '\x2', '\x2', '\xB8', '\xB7', '\x3', '\x2', '\x2', 
		'\x2', '\xB9', '\xBC', '\x3', '\x2', '\x2', '\x2', '\xBA', '\xB8', '\x3', 
		'\x2', '\x2', '\x2', '\xBA', '\xBB', '\x3', '\x2', '\x2', '\x2', '\xBB', 
		'\v', '\x3', '\x2', '\x2', '\x2', '\xBC', '\xBA', '\x3', '\x2', '\x2', 
		'\x2', '\xBD', '\xC1', '\x5', '\\', '/', '\x2', '\xBE', '\xC1', '\x5', 
		'\x66', '\x34', '\x2', '\xBF', '\xC1', '\a', '\x17', '\x2', '\x2', '\xC0', 
		'\xBD', '\x3', '\x2', '\x2', '\x2', '\xC0', '\xBE', '\x3', '\x2', '\x2', 
		'\x2', '\xC0', '\xBF', '\x3', '\x2', '\x2', '\x2', '\xC1', '\r', '\x3', 
		'\x2', '\x2', '\x2', '\xC2', '\xC6', '\a', '!', '\x2', '\x2', '\xC3', 
		'\xC5', '\x5', '\x12', '\n', '\x2', '\xC4', '\xC3', '\x3', '\x2', '\x2', 
		'\x2', '\xC5', '\xC8', '\x3', '\x2', '\x2', '\x2', '\xC6', '\xC4', '\x3', 
		'\x2', '\x2', '\x2', '\xC6', '\xC7', '\x3', '\x2', '\x2', '\x2', '\xC7', 
		'\xC9', '\x3', '\x2', '\x2', '\x2', '\xC8', '\xC6', '\x3', '\x2', '\x2', 
		'\x2', '\xC9', '\xCD', '\a', '\"', '\x2', '\x2', '\xCA', '\xCC', '\a', 
		'\x17', '\x2', '\x2', '\xCB', '\xCA', '\x3', '\x2', '\x2', '\x2', '\xCC', 
		'\xCF', '\x3', '\x2', '\x2', '\x2', '\xCD', '\xCB', '\x3', '\x2', '\x2', 
		'\x2', '\xCD', '\xCE', '\x3', '\x2', '\x2', '\x2', '\xCE', '\xF', '\x3', 
		'\x2', '\x2', '\x2', '\xCF', '\xCD', '\x3', '\x2', '\x2', '\x2', '\xD0', 
		'\xD2', '\x5', '\x1C', '\xF', '\x2', '\xD1', '\xD3', '\x5', '\x14', '\v', 
		'\x2', '\xD2', '\xD1', '\x3', '\x2', '\x2', '\x2', '\xD2', '\xD3', '\x3', 
		'\x2', '\x2', '\x2', '\xD3', '\xD4', '\x3', '\x2', '\x2', '\x2', '\xD4', 
		'\xD5', '\a', '#', '\x2', '\x2', '\xD5', '\xD6', '\a', '\x44', '\x2', 
		'\x2', '\xD6', '\xDA', '\x5', '\x16', '\f', '\x2', '\xD7', '\xD9', '\x5', 
		' ', '\x11', '\x2', '\xD8', '\xD7', '\x3', '\x2', '\x2', '\x2', '\xD9', 
		'\xDC', '\x3', '\x2', '\x2', '\x2', '\xDA', '\xD8', '\x3', '\x2', '\x2', 
		'\x2', '\xDA', '\xDB', '\x3', '\x2', '\x2', '\x2', '\xDB', '\xDD', '\x3', 
		'\x2', '\x2', '\x2', '\xDC', '\xDA', '\x3', '\x2', '\x2', '\x2', '\xDD', 
		'\xDE', '\x5', '\x44', '#', '\x2', '\xDE', '\xDF', '\a', '\x17', '\x2', 
		'\x2', '\xDF', '\xE0', '\a', '$', '\x2', '\x2', '\xE0', '\xE1', '\a', 
		'\x17', '\x2', '\x2', '\xE1', '\xF0', '\x3', '\x2', '\x2', '\x2', '\xE2', 
		'\xE3', '\a', '\'', '\x2', '\x2', '\xE3', '\xE4', '\a', '#', '\x2', '\x2', 
		'\xE4', '\xE5', '\a', '\x44', '\x2', '\x2', '\xE5', '\xE9', '\x5', '\x16', 
		'\f', '\x2', '\xE6', '\xE8', '\x5', ' ', '\x11', '\x2', '\xE7', '\xE6', 
		'\x3', '\x2', '\x2', '\x2', '\xE8', '\xEB', '\x3', '\x2', '\x2', '\x2', 
		'\xE9', '\xE7', '\x3', '\x2', '\x2', '\x2', '\xE9', '\xEA', '\x3', '\x2', 
		'\x2', '\x2', '\xEA', '\xEC', '\x3', '\x2', '\x2', '\x2', '\xEB', '\xE9', 
		'\x3', '\x2', '\x2', '\x2', '\xEC', '\xED', '\a', '$', '\x2', '\x2', '\xED', 
		'\xEE', '\a', '\x17', '\x2', '\x2', '\xEE', '\xF0', '\x3', '\x2', '\x2', 
		'\x2', '\xEF', '\xD0', '\x3', '\x2', '\x2', '\x2', '\xEF', '\xE2', '\x3', 
		'\x2', '\x2', '\x2', '\xF0', '\x11', '\x3', '\x2', '\x2', '\x2', '\xF1', 
		'\xF4', '\x5', '\x10', '\t', '\x2', '\xF2', '\xF4', '\a', '\x17', '\x2', 
		'\x2', '\xF3', '\xF1', '\x3', '\x2', '\x2', '\x2', '\xF3', '\xF2', '\x3', 
		'\x2', '\x2', '\x2', '\xF4', '\x13', '\x3', '\x2', '\x2', '\x2', '\xF5', 
		'\xF6', '\a', '\b', '\x2', '\x2', '\xF6', '\xF7', '\a', '\t', '\x2', '\x2', 
		'\xF7', '\x15', '\x3', '\x2', '\x2', '\x2', '\xF8', '\xFA', '\a', '\x6', 
		'\x2', '\x2', '\xF9', '\xFB', '\x5', '\x18', '\r', '\x2', '\xFA', '\xF9', 
		'\x3', '\x2', '\x2', '\x2', '\xFA', '\xFB', '\x3', '\x2', '\x2', '\x2', 
		'\xFB', '\xFC', '\x3', '\x2', '\x2', '\x2', '\xFC', '\xFD', '\a', '\a', 
		'\x2', '\x2', '\xFD', '\x17', '\x3', '\x2', '\x2', '\x2', '\xFE', '\x100', 
		'\x5', '\x1E', '\x10', '\x2', '\xFF', '\x101', '\x5', '\x14', '\v', '\x2', 
		'\x100', '\xFF', '\x3', '\x2', '\x2', '\x2', '\x100', '\x101', '\x3', 
		'\x2', '\x2', '\x2', '\x101', '\x102', '\x3', '\x2', '\x2', '\x2', '\x102', 
		'\x106', '\a', '\x44', '\x2', '\x2', '\x103', '\x105', '\x5', '\x1A', 
		'\xE', '\x2', '\x104', '\x103', '\x3', '\x2', '\x2', '\x2', '\x105', '\x108', 
		'\x3', '\x2', '\x2', '\x2', '\x106', '\x104', '\x3', '\x2', '\x2', '\x2', 
		'\x106', '\x107', '\x3', '\x2', '\x2', '\x2', '\x107', '\x19', '\x3', 
		'\x2', '\x2', '\x2', '\x108', '\x106', '\x3', '\x2', '\x2', '\x2', '\x109', 
		'\x10A', '\a', '\x18', '\x2', '\x2', '\x10A', '\x10C', '\x5', '\x1E', 
		'\x10', '\x2', '\x10B', '\x10D', '\x5', '\x14', '\v', '\x2', '\x10C', 
		'\x10B', '\x3', '\x2', '\x2', '\x2', '\x10C', '\x10D', '\x3', '\x2', '\x2', 
		'\x2', '\x10D', '\x10E', '\x3', '\x2', '\x2', '\x2', '\x10E', '\x10F', 
		'\a', '\x44', '\x2', '\x2', '\x10F', '\x1B', '\x3', '\x2', '\x2', '\x2', 
		'\x110', '\x111', '\t', '\x2', '\x2', '\x2', '\x111', '\x1D', '\x3', '\x2', 
		'\x2', '\x2', '\x112', '\x115', '\x5', 'j', '\x36', '\x2', '\x113', '\x115', 
		'\x5', '\x1C', '\xF', '\x2', '\x114', '\x112', '\x3', '\x2', '\x2', '\x2', 
		'\x114', '\x113', '\x3', '\x2', '\x2', '\x2', '\x115', '\x1F', '\x3', 
		'\x2', '\x2', '\x2', '\x116', '\x118', '\x5', '\"', '\x12', '\x2', '\x117', 
		'\x116', '\x3', '\x2', '\x2', '\x2', '\x117', '\x118', '\x3', '\x2', '\x2', 
		'\x2', '\x118', '\x119', '\x3', '\x2', '\x2', '\x2', '\x119', '\x11A', 
		'\a', '\x17', '\x2', '\x2', '\x11A', '!', '\x3', '\x2', '\x2', '\x2', 
		'\x11B', '\x123', '\x5', '*', '\x16', '\x2', '\x11C', '\x123', '\x5', 
		'\x36', '\x1C', '\x2', '\x11D', '\x123', '\x5', '\x38', '\x1D', '\x2', 
		'\x11E', '\x123', '\x5', '\\', '/', '\x2', '\x11F', '\x123', '\x5', '<', 
		'\x1F', '\x2', '\x120', '\x123', '\x5', '>', ' ', '\x2', '\x121', '\x123', 
		'\x5', '\x44', '#', '\x2', '\x122', '\x11B', '\x3', '\x2', '\x2', '\x2', 
		'\x122', '\x11C', '\x3', '\x2', '\x2', '\x2', '\x122', '\x11D', '\x3', 
		'\x2', '\x2', '\x2', '\x122', '\x11E', '\x3', '\x2', '\x2', '\x2', '\x122', 
		'\x11F', '\x3', '\x2', '\x2', '\x2', '\x122', '\x120', '\x3', '\x2', '\x2', 
		'\x2', '\x122', '\x121', '\x3', '\x2', '\x2', '\x2', '\x123', '#', '\x3', 
		'\x2', '\x2', '\x2', '\x124', '\x126', '\x5', '&', '\x14', '\x2', '\x125', 
		'\x124', '\x3', '\x2', '\x2', '\x2', '\x125', '\x126', '\x3', '\x2', '\x2', 
		'\x2', '\x126', '\x127', '\x3', '\x2', '\x2', '\x2', '\x127', '\x128', 
		'\a', '\x17', '\x2', '\x2', '\x128', '%', '\x3', '\x2', '\x2', '\x2', 
		'\x129', '\x131', '\x5', '\x30', '\x19', '\x2', '\x12A', '\x131', '\x5', 
		'\x36', '\x1C', '\x2', '\x12B', '\x131', '\x5', '\x38', '\x1D', '\x2', 
		'\x12C', '\x131', '\x5', '\\', '/', '\x2', '\x12D', '\x131', '\x5', '<', 
		'\x1F', '\x2', '\x12E', '\x131', '\x5', '>', ' ', '\x2', '\x12F', '\x131', 
		'\x5', '\x44', '#', '\x2', '\x130', '\x129', '\x3', '\x2', '\x2', '\x2', 
		'\x130', '\x12A', '\x3', '\x2', '\x2', '\x2', '\x130', '\x12B', '\x3', 
		'\x2', '\x2', '\x2', '\x130', '\x12C', '\x3', '\x2', '\x2', '\x2', '\x130', 
		'\x12D', '\x3', '\x2', '\x2', '\x2', '\x130', '\x12E', '\x3', '\x2', '\x2', 
		'\x2', '\x130', '\x12F', '\x3', '\x2', '\x2', '\x2', '\x131', '\'', '\x3', 
		'\x2', '\x2', '\x2', '\x132', '\x138', '\x5', '$', '\x13', '\x2', '\x133', 
		'\x134', '\a', '\x30', '\x2', '\x2', '\x134', '\x138', '\a', '\x17', '\x2', 
		'\x2', '\x135', '\x136', '\a', '\x31', '\x2', '\x2', '\x136', '\x138', 
		'\a', '\x17', '\x2', '\x2', '\x137', '\x132', '\x3', '\x2', '\x2', '\x2', 
		'\x137', '\x133', '\x3', '\x2', '\x2', '\x2', '\x137', '\x135', '\x3', 
		'\x2', '\x2', '\x2', '\x138', ')', '\x3', '\x2', '\x2', '\x2', '\x139', 
		'\x13A', '\a', '-', '\x2', '\x2', '\x13A', '\x13B', '\a', '\x6', '\x2', 
		'\x2', '\x13B', '\x13C', '\x5', 'R', '*', '\x2', '\x13C', '\x140', '\a', 
		'\a', '\x2', '\x2', '\x13D', '\x13F', '\x5', ' ', '\x11', '\x2', '\x13E', 
		'\x13D', '\x3', '\x2', '\x2', '\x2', '\x13F', '\x142', '\x3', '\x2', '\x2', 
		'\x2', '\x140', '\x13E', '\x3', '\x2', '\x2', '\x2', '\x140', '\x141', 
		'\x3', '\x2', '\x2', '\x2', '\x141', '\x146', '\x3', '\x2', '\x2', '\x2', 
		'\x142', '\x140', '\x3', '\x2', '\x2', '\x2', '\x143', '\x145', '\x5', 
		',', '\x17', '\x2', '\x144', '\x143', '\x3', '\x2', '\x2', '\x2', '\x145', 
		'\x148', '\x3', '\x2', '\x2', '\x2', '\x146', '\x144', '\x3', '\x2', '\x2', 
		'\x2', '\x146', '\x147', '\x3', '\x2', '\x2', '\x2', '\x147', '\x14A', 
		'\x3', '\x2', '\x2', '\x2', '\x148', '\x146', '\x3', '\x2', '\x2', '\x2', 
		'\x149', '\x14B', '\x5', '.', '\x18', '\x2', '\x14A', '\x149', '\x3', 
		'\x2', '\x2', '\x2', '\x14A', '\x14B', '\x3', '\x2', '\x2', '\x2', '\x14B', 
		'\x14C', '\x3', '\x2', '\x2', '\x2', '\x14C', '\x14D', '\a', '.', '\x2', 
		'\x2', '\x14D', '+', '\x3', '\x2', '\x2', '\x2', '\x14E', '\x14F', '\a', 
		'/', '\x2', '\x2', '\x14F', '\x150', '\a', '-', '\x2', '\x2', '\x150', 
		'\x151', '\a', '\x6', '\x2', '\x2', '\x151', '\x152', '\x5', 'R', '*', 
		'\x2', '\x152', '\x156', '\a', '\a', '\x2', '\x2', '\x153', '\x155', '\x5', 
		' ', '\x11', '\x2', '\x154', '\x153', '\x3', '\x2', '\x2', '\x2', '\x155', 
		'\x158', '\x3', '\x2', '\x2', '\x2', '\x156', '\x154', '\x3', '\x2', '\x2', 
		'\x2', '\x156', '\x157', '\x3', '\x2', '\x2', '\x2', '\x157', '-', '\x3', 
		'\x2', '\x2', '\x2', '\x158', '\x156', '\x3', '\x2', '\x2', '\x2', '\x159', 
		'\x15D', '\a', '/', '\x2', '\x2', '\x15A', '\x15C', '\x5', ' ', '\x11', 
		'\x2', '\x15B', '\x15A', '\x3', '\x2', '\x2', '\x2', '\x15C', '\x15F', 
		'\x3', '\x2', '\x2', '\x2', '\x15D', '\x15B', '\x3', '\x2', '\x2', '\x2', 
		'\x15D', '\x15E', '\x3', '\x2', '\x2', '\x2', '\x15E', '/', '\x3', '\x2', 
		'\x2', '\x2', '\x15F', '\x15D', '\x3', '\x2', '\x2', '\x2', '\x160', '\x161', 
		'\a', '-', '\x2', '\x2', '\x161', '\x162', '\a', '\x6', '\x2', '\x2', 
		'\x162', '\x163', '\x5', 'R', '*', '\x2', '\x163', '\x167', '\a', '\a', 
		'\x2', '\x2', '\x164', '\x166', '\x5', '(', '\x15', '\x2', '\x165', '\x164', 
		'\x3', '\x2', '\x2', '\x2', '\x166', '\x169', '\x3', '\x2', '\x2', '\x2', 
		'\x167', '\x165', '\x3', '\x2', '\x2', '\x2', '\x167', '\x168', '\x3', 
		'\x2', '\x2', '\x2', '\x168', '\x16D', '\x3', '\x2', '\x2', '\x2', '\x169', 
		'\x167', '\x3', '\x2', '\x2', '\x2', '\x16A', '\x16C', '\x5', '\x32', 
		'\x1A', '\x2', '\x16B', '\x16A', '\x3', '\x2', '\x2', '\x2', '\x16C', 
		'\x16F', '\x3', '\x2', '\x2', '\x2', '\x16D', '\x16B', '\x3', '\x2', '\x2', 
		'\x2', '\x16D', '\x16E', '\x3', '\x2', '\x2', '\x2', '\x16E', '\x171', 
		'\x3', '\x2', '\x2', '\x2', '\x16F', '\x16D', '\x3', '\x2', '\x2', '\x2', 
		'\x170', '\x172', '\x5', '\x34', '\x1B', '\x2', '\x171', '\x170', '\x3', 
		'\x2', '\x2', '\x2', '\x171', '\x172', '\x3', '\x2', '\x2', '\x2', '\x172', 
		'\x173', '\x3', '\x2', '\x2', '\x2', '\x173', '\x174', '\a', '.', '\x2', 
		'\x2', '\x174', '\x31', '\x3', '\x2', '\x2', '\x2', '\x175', '\x176', 
		'\a', '/', '\x2', '\x2', '\x176', '\x177', '\a', '-', '\x2', '\x2', '\x177', 
		'\x178', '\a', '\x6', '\x2', '\x2', '\x178', '\x179', '\x5', 'R', '*', 
		'\x2', '\x179', '\x17D', '\a', '\a', '\x2', '\x2', '\x17A', '\x17C', '\x5', 
		'(', '\x15', '\x2', '\x17B', '\x17A', '\x3', '\x2', '\x2', '\x2', '\x17C', 
		'\x17F', '\x3', '\x2', '\x2', '\x2', '\x17D', '\x17B', '\x3', '\x2', '\x2', 
		'\x2', '\x17D', '\x17E', '\x3', '\x2', '\x2', '\x2', '\x17E', '\x33', 
		'\x3', '\x2', '\x2', '\x2', '\x17F', '\x17D', '\x3', '\x2', '\x2', '\x2', 
		'\x180', '\x184', '\a', '/', '\x2', '\x2', '\x181', '\x183', '\x5', '(', 
		'\x15', '\x2', '\x182', '\x181', '\x3', '\x2', '\x2', '\x2', '\x183', 
		'\x186', '\x3', '\x2', '\x2', '\x2', '\x184', '\x182', '\x3', '\x2', '\x2', 
		'\x2', '\x184', '\x185', '\x3', '\x2', '\x2', '\x2', '\x185', '\x35', 
		'\x3', '\x2', '\x2', '\x2', '\x186', '\x184', '\x3', '\x2', '\x2', '\x2', 
		'\x187', '\x188', '\a', '\x32', '\x2', '\x2', '\x188', '\x189', '\a', 
		'\x6', '\x2', '\x2', '\x189', '\x18A', '\x5', 'R', '*', '\x2', '\x18A', 
		'\x18E', '\a', '\a', '\x2', '\x2', '\x18B', '\x18D', '\x5', '$', '\x13', 
		'\x2', '\x18C', '\x18B', '\x3', '\x2', '\x2', '\x2', '\x18D', '\x190', 
		'\x3', '\x2', '\x2', '\x2', '\x18E', '\x18C', '\x3', '\x2', '\x2', '\x2', 
		'\x18E', '\x18F', '\x3', '\x2', '\x2', '\x2', '\x18F', '\x191', '\x3', 
		'\x2', '\x2', '\x2', '\x190', '\x18E', '\x3', '\x2', '\x2', '\x2', '\x191', 
		'\x192', '\a', '\x33', '\x2', '\x2', '\x192', '\x37', '\x3', '\x2', '\x2', 
		'\x2', '\x193', '\x194', '\a', '\x34', '\x2', '\x2', '\x194', '\x195', 
		'\a', '\x6', '\x2', '\x2', '\x195', '\x196', '\x5', ':', '\x1E', '\x2', 
		'\x196', '\x197', '\a', '\x36', '\x2', '\x2', '\x197', '\x198', '\x5', 
		'H', '%', '\x2', '\x198', '\x199', '\a', '\x18', '\x2', '\x2', '\x199', 
		'\x19A', '\a', '\x37', '\x2', '\x2', '\x19A', '\x19B', '\x5', 'H', '%', 
		'\x2', '\x19B', '\x19F', '\a', '\a', '\x2', '\x2', '\x19C', '\x19E', '\x5', 
		'$', '\x13', '\x2', '\x19D', '\x19C', '\x3', '\x2', '\x2', '\x2', '\x19E', 
		'\x1A1', '\x3', '\x2', '\x2', '\x2', '\x19F', '\x19D', '\x3', '\x2', '\x2', 
		'\x2', '\x19F', '\x1A0', '\x3', '\x2', '\x2', '\x2', '\x1A0', '\x1A2', 
		'\x3', '\x2', '\x2', '\x2', '\x1A1', '\x19F', '\x3', '\x2', '\x2', '\x2', 
		'\x1A2', '\x1A3', '\a', '\x35', '\x2', '\x2', '\x1A3', '\x39', '\x3', 
		'\x2', '\x2', '\x2', '\x1A4', '\x1AB', '\x5', '`', '\x31', '\x2', '\x1A5', 
		'\x1AB', '\x5', '<', '\x1F', '\x2', '\x1A6', '\x1A8', '\a', '\x44', '\x2', 
		'\x2', '\x1A7', '\x1A9', '\x5', '\x46', '$', '\x2', '\x1A8', '\x1A7', 
		'\x3', '\x2', '\x2', '\x2', '\x1A8', '\x1A9', '\x3', '\x2', '\x2', '\x2', 
		'\x1A9', '\x1AB', '\x3', '\x2', '\x2', '\x2', '\x1AA', '\x1A4', '\x3', 
		'\x2', '\x2', '\x2', '\x1AA', '\x1A5', '\x3', '\x2', '\x2', '\x2', '\x1AA', 
		'\x1A6', '\x3', '\x2', '\x2', '\x2', '\x1AB', ';', '\x3', '\x2', '\x2', 
		'\x2', '\x1AC', '\x1AE', '\a', '\x44', '\x2', '\x2', '\x1AD', '\x1AF', 
		'\x5', '\x46', '$', '\x2', '\x1AE', '\x1AD', '\x3', '\x2', '\x2', '\x2', 
		'\x1AE', '\x1AF', '\x3', '\x2', '\x2', '\x2', '\x1AF', '\x1B0', '\x3', 
		'\x2', '\x2', '\x2', '\x1B0', '\x1B1', '\a', '\n', '\x2', '\x2', '\x1B1', 
		'\x1B2', '\x5', 'R', '*', '\x2', '\x1B2', '=', '\x3', '\x2', '\x2', '\x2', 
		'\x1B3', '\x1B4', '\a', '\x44', '\x2', '\x2', '\x1B4', '\x1B6', '\a', 
		'\x6', '\x2', '\x2', '\x1B5', '\x1B7', '\x5', '@', '!', '\x2', '\x1B6', 
		'\x1B5', '\x3', '\x2', '\x2', '\x2', '\x1B6', '\x1B7', '\x3', '\x2', '\x2', 
		'\x2', '\x1B7', '\x1B8', '\x3', '\x2', '\x2', '\x2', '\x1B8', '\x1B9', 
		'\a', '\a', '\x2', '\x2', '\x1B9', '?', '\x3', '\x2', '\x2', '\x2', '\x1BA', 
		'\x1BE', '\x5', 'R', '*', '\x2', '\x1BB', '\x1BD', '\x5', '\x42', '\"', 
		'\x2', '\x1BC', '\x1BB', '\x3', '\x2', '\x2', '\x2', '\x1BD', '\x1C0', 
		'\x3', '\x2', '\x2', '\x2', '\x1BE', '\x1BC', '\x3', '\x2', '\x2', '\x2', 
		'\x1BE', '\x1BF', '\x3', '\x2', '\x2', '\x2', '\x1BF', '\x41', '\x3', 
		'\x2', '\x2', '\x2', '\x1C0', '\x1BE', '\x3', '\x2', '\x2', '\x2', '\x1C1', 
		'\x1C2', '\a', '\x18', '\x2', '\x2', '\x1C2', '\x1C3', '\x5', 'R', '*', 
		'\x2', '\x1C3', '\x43', '\x3', '\x2', '\x2', '\x2', '\x1C4', '\x1C6', 
		'\a', '>', '\x2', '\x2', '\x1C5', '\x1C7', '\x5', 'R', '*', '\x2', '\x1C6', 
		'\x1C5', '\x3', '\x2', '\x2', '\x2', '\x1C6', '\x1C7', '\x3', '\x2', '\x2', 
		'\x2', '\x1C7', '\x45', '\x3', '\x2', '\x2', '\x2', '\x1C8', '\x1C9', 
		'\a', '\b', '\x2', '\x2', '\x1C9', '\x1CA', '\x5', 'H', '%', '\x2', '\x1CA', 
		'\x1CB', '\a', '\t', '\x2', '\x2', '\x1CB', 'G', '\x3', '\x2', '\x2', 
		'\x2', '\x1CC', '\x1CD', '\b', '%', '\x1', '\x2', '\x1CD', '\x1CE', '\x5', 
		'J', '&', '\x2', '\x1CE', '\x1D7', '\x3', '\x2', '\x2', '\x2', '\x1CF', 
		'\x1D0', '\f', '\x5', '\x2', '\x2', '\x1D0', '\x1D1', '\a', '\v', '\x2', 
		'\x2', '\x1D1', '\x1D6', '\x5', 'J', '&', '\x2', '\x1D2', '\x1D3', '\f', 
		'\x4', '\x2', '\x2', '\x1D3', '\x1D4', '\a', '\f', '\x2', '\x2', '\x1D4', 
		'\x1D6', '\x5', 'J', '&', '\x2', '\x1D5', '\x1CF', '\x3', '\x2', '\x2', 
		'\x2', '\x1D5', '\x1D2', '\x3', '\x2', '\x2', '\x2', '\x1D6', '\x1D9', 
		'\x3', '\x2', '\x2', '\x2', '\x1D7', '\x1D5', '\x3', '\x2', '\x2', '\x2', 
		'\x1D7', '\x1D8', '\x3', '\x2', '\x2', '\x2', '\x1D8', 'I', '\x3', '\x2', 
		'\x2', '\x2', '\x1D9', '\x1D7', '\x3', '\x2', '\x2', '\x2', '\x1DA', '\x1DB', 
		'\b', '&', '\x1', '\x2', '\x1DB', '\x1DC', '\x5', 'L', '\'', '\x2', '\x1DC', 
		'\x1E5', '\x3', '\x2', '\x2', '\x2', '\x1DD', '\x1DE', '\f', '\x5', '\x2', 
		'\x2', '\x1DE', '\x1DF', '\a', '\xE', '\x2', '\x2', '\x1DF', '\x1E4', 
		'\x5', 'L', '\'', '\x2', '\x1E0', '\x1E1', '\f', '\x4', '\x2', '\x2', 
		'\x1E1', '\x1E2', '\a', '\r', '\x2', '\x2', '\x1E2', '\x1E4', '\x5', 'L', 
		'\'', '\x2', '\x1E3', '\x1DD', '\x3', '\x2', '\x2', '\x2', '\x1E3', '\x1E0', 
		'\x3', '\x2', '\x2', '\x2', '\x1E4', '\x1E7', '\x3', '\x2', '\x2', '\x2', 
		'\x1E5', '\x1E3', '\x3', '\x2', '\x2', '\x2', '\x1E5', '\x1E6', '\x3', 
		'\x2', '\x2', '\x2', '\x1E6', 'K', '\x3', '\x2', '\x2', '\x2', '\x1E7', 
		'\x1E5', '\x3', '\x2', '\x2', '\x2', '\x1E8', '\x1E9', '\b', '\'', '\x1', 
		'\x2', '\x1E9', '\x1EA', '\x5', 'N', '(', '\x2', '\x1EA', '\x1F0', '\x3', 
		'\x2', '\x2', '\x2', '\x1EB', '\x1EC', '\f', '\x4', '\x2', '\x2', '\x1EC', 
		'\x1ED', '\a', '\xF', '\x2', '\x2', '\x1ED', '\x1EF', '\x5', 'N', '(', 
		'\x2', '\x1EE', '\x1EB', '\x3', '\x2', '\x2', '\x2', '\x1EF', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1F0', '\x1EE', '\x3', '\x2', '\x2', '\x2', 
		'\x1F0', '\x1F1', '\x3', '\x2', '\x2', '\x2', '\x1F1', 'M', '\x3', '\x2', 
		'\x2', '\x2', '\x1F2', '\x1F0', '\x3', '\x2', '\x2', '\x2', '\x1F3', '\x1F5', 
		'\a', '\f', '\x2', '\x2', '\x1F4', '\x1F3', '\x3', '\x2', '\x2', '\x2', 
		'\x1F4', '\x1F5', '\x3', '\x2', '\x2', '\x2', '\x1F5', '\x200', '\x3', 
		'\x2', '\x2', '\x2', '\x1F6', '\x201', '\x5', 'P', ')', '\x2', '\x1F7', 
		'\x1F9', '\a', '\x44', '\x2', '\x2', '\x1F8', '\x1FA', '\x5', '\x46', 
		'$', '\x2', '\x1F9', '\x1F8', '\x3', '\x2', '\x2', '\x2', '\x1F9', '\x1FA', 
		'\x3', '\x2', '\x2', '\x2', '\x1FA', '\x201', '\x3', '\x2', '\x2', '\x2', 
		'\x1FB', '\x1FC', '\a', '\x6', '\x2', '\x2', '\x1FC', '\x1FD', '\x5', 
		'R', '*', '\x2', '\x1FD', '\x1FE', '\a', '\a', '\x2', '\x2', '\x1FE', 
		'\x201', '\x3', '\x2', '\x2', '\x2', '\x1FF', '\x201', '\x5', '>', ' ', 
		'\x2', '\x200', '\x1F6', '\x3', '\x2', '\x2', '\x2', '\x200', '\x1F7', 
		'\x3', '\x2', '\x2', '\x2', '\x200', '\x1FB', '\x3', '\x2', '\x2', '\x2', 
		'\x200', '\x1FF', '\x3', '\x2', '\x2', '\x2', '\x201', 'O', '\x3', '\x2', 
		'\x2', '\x2', '\x202', '\x203', '\t', '\x3', '\x2', '\x2', '\x203', 'Q', 
		'\x3', '\x2', '\x2', '\x2', '\x204', '\x205', '\b', '*', '\x1', '\x2', 
		'\x205', '\x206', '\x5', 'T', '+', '\x2', '\x206', '\x20F', '\x3', '\x2', 
		'\x2', '\x2', '\x207', '\x208', '\f', '\x5', '\x2', '\x2', '\x208', '\x209', 
		'\a', '?', '\x2', '\x2', '\x209', '\x20E', '\x5', 'T', '+', '\x2', '\x20A', 
		'\x20B', '\f', '\x4', '\x2', '\x2', '\x20B', '\x20C', '\a', '@', '\x2', 
		'\x2', '\x20C', '\x20E', '\x5', 'T', '+', '\x2', '\x20D', '\x207', '\x3', 
		'\x2', '\x2', '\x2', '\x20D', '\x20A', '\x3', '\x2', '\x2', '\x2', '\x20E', 
		'\x211', '\x3', '\x2', '\x2', '\x2', '\x20F', '\x20D', '\x3', '\x2', '\x2', 
		'\x2', '\x20F', '\x210', '\x3', '\x2', '\x2', '\x2', '\x210', 'S', '\x3', 
		'\x2', '\x2', '\x2', '\x211', '\x20F', '\x3', '\x2', '\x2', '\x2', '\x212', 
		'\x213', '\x5', 'V', ',', '\x2', '\x213', '\x214', '\a', '\x14', '\x2', 
		'\x2', '\x214', '\x215', '\x5', 'V', ',', '\x2', '\x215', '\x21C', '\x3', 
		'\x2', '\x2', '\x2', '\x216', '\x217', '\x5', 'V', ',', '\x2', '\x217', 
		'\x218', '\a', '\x15', '\x2', '\x2', '\x218', '\x219', '\x5', 'V', ',', 
		'\x2', '\x219', '\x21C', '\x3', '\x2', '\x2', '\x2', '\x21A', '\x21C', 
		'\x5', 'V', ',', '\x2', '\x21B', '\x212', '\x3', '\x2', '\x2', '\x2', 
		'\x21B', '\x216', '\x3', '\x2', '\x2', '\x2', '\x21B', '\x21A', '\x3', 
		'\x2', '\x2', '\x2', '\x21C', 'U', '\x3', '\x2', '\x2', '\x2', '\x21D', 
		'\x21E', '\x5', 'Z', '.', '\x2', '\x21E', '\x21F', '\x5', 'X', '-', '\x2', 
		'\x21F', '\x220', '\x5', 'Z', '.', '\x2', '\x220', '\x223', '\x3', '\x2', 
		'\x2', '\x2', '\x221', '\x223', '\x5', 'Z', '.', '\x2', '\x222', '\x21D', 
		'\x3', '\x2', '\x2', '\x2', '\x222', '\x221', '\x3', '\x2', '\x2', '\x2', 
		'\x223', 'W', '\x3', '\x2', '\x2', '\x2', '\x224', '\x225', '\t', '\x4', 
		'\x2', '\x2', '\x225', 'Y', '\x3', '\x2', '\x2', '\x2', '\x226', '\x228', 
		'\a', '\x16', '\x2', '\x2', '\x227', '\x226', '\x3', '\x2', '\x2', '\x2', 
		'\x227', '\x228', '\x3', '\x2', '\x2', '\x2', '\x228', '\x229', '\x3', 
		'\x2', '\x2', '\x2', '\x229', '\x22A', '\x5', 'H', '%', '\x2', '\x22A', 
		'[', '\x3', '\x2', '\x2', '\x2', '\x22B', '\x22D', '\a', '\x41', '\x2', 
		'\x2', '\x22C', '\x22B', '\x3', '\x2', '\x2', '\x2', '\x22C', '\x22D', 
		'\x3', '\x2', '\x2', '\x2', '\x22D', '\x22E', '\x3', '\x2', '\x2', '\x2', 
		'\x22E', '\x22F', '\x5', '^', '\x30', '\x2', '\x22F', ']', '\x3', '\x2', 
		'\x2', '\x2', '\x230', '\x235', '\x5', '`', '\x31', '\x2', '\x231', '\x235', 
		'\x5', '\x62', '\x32', '\x2', '\x232', '\x235', '\x5', '\x64', '\x33', 
		'\x2', '\x233', '\x235', '\x5', 'l', '\x37', '\x2', '\x234', '\x230', 
		'\x3', '\x2', '\x2', '\x2', '\x234', '\x231', '\x3', '\x2', '\x2', '\x2', 
		'\x234', '\x232', '\x3', '\x2', '\x2', '\x2', '\x234', '\x233', '\x3', 
		'\x2', '\x2', '\x2', '\x235', '_', '\x3', '\x2', '\x2', '\x2', '\x236', 
		'\x237', '\a', '(', '\x2', '\x2', '\x237', '\x238', '\a', '\x44', '\x2', 
		'\x2', '\x238', '\x239', '\a', '\n', '\x2', '\x2', '\x239', '\x23A', '\x5', 
		'H', '%', '\x2', '\x23A', '\x61', '\x3', '\x2', '\x2', '\x2', '\x23B', 
		'\x23C', '\a', ')', '\x2', '\x2', '\x23C', '\x23D', '\a', '\x44', '\x2', 
		'\x2', '\x23D', '\x23E', '\a', '\n', '\x2', '\x2', '\x23E', '\x23F', '\x5', 
		'H', '%', '\x2', '\x23F', '\x63', '\x3', '\x2', '\x2', '\x2', '\x240', 
		'\x241', '\a', '*', '\x2', '\x2', '\x241', '\x242', '\a', '\x44', '\x2', 
		'\x2', '\x242', '\x243', '\a', '\n', '\x2', '\x2', '\x243', '\x244', '\x5', 
		'R', '*', '\x2', '\x244', '\x65', '\x3', '\x2', '\x2', '\x2', '\x245', 
		'\x246', '\x5', 'h', '\x35', '\x2', '\x246', '\x247', '\x5', 'j', '\x36', 
		'\x2', '\x247', '\x248', '\a', '\x44', '\x2', '\x2', '\x248', '\x249', 
		'\a', '\n', '\x2', '\x2', '\x249', '\x24A', '\a', '\x19', '\x2', '\x2', 
		'\x24A', 'g', '\x3', '\x2', '\x2', '\x2', '\x24B', '\x24C', '\t', '\x5', 
		'\x2', '\x2', '\x24C', 'i', '\x3', '\x2', '\x2', '\x2', '\x24D', '\x24E', 
		'\t', '\x6', '\x2', '\x2', '\x24E', 'k', '\x3', '\x2', '\x2', '\x2', '\x24F', 
		'\x250', '\x5', '\x1C', '\xF', '\x2', '\x250', '\x251', '\x5', 'p', '\x39', 
		'\x2', '\x251', '\x254', '\a', '\x44', '\x2', '\x2', '\x252', '\x253', 
		'\a', '\n', '\x2', '\x2', '\x253', '\x255', '\x5', 'n', '\x38', '\x2', 
		'\x254', '\x252', '\x3', '\x2', '\x2', '\x2', '\x254', '\x255', '\x3', 
		'\x2', '\x2', '\x2', '\x255', 'm', '\x3', '\x2', '\x2', '\x2', '\x256', 
		'\x25D', '\a', '\x44', '\x2', '\x2', '\x257', '\x259', '\a', '\b', '\x2', 
		'\x2', '\x258', '\x25A', '\x5', '@', '!', '\x2', '\x259', '\x258', '\x3', 
		'\x2', '\x2', '\x2', '\x259', '\x25A', '\x3', '\x2', '\x2', '\x2', '\x25A', 
		'\x25B', '\x3', '\x2', '\x2', '\x2', '\x25B', '\x25D', '\a', '\t', '\x2', 
		'\x2', '\x25C', '\x256', '\x3', '\x2', '\x2', '\x2', '\x25C', '\x257', 
		'\x3', '\x2', '\x2', '\x2', '\x25D', 'o', '\x3', '\x2', '\x2', '\x2', 
		'\x25E', '\x25F', '\a', '\b', '\x2', '\x2', '\x25F', '\x260', '\a', '\x19', 
		'\x2', '\x2', '\x260', '\x261', '\a', '\t', '\x2', '\x2', '\x261', 'q', 
		'\x3', '\x2', '\x2', '\x2', '\x44', 'u', 'y', '}', '\x83', '\x8A', '\x91', 
		'\x98', '\x9B', '\xA1', '\xAA', '\xB3', '\xBA', '\xC0', '\xC6', '\xCD', 
		'\xD2', '\xDA', '\xE9', '\xEF', '\xF3', '\xFA', '\x100', '\x106', '\x10C', 
		'\x114', '\x117', '\x122', '\x125', '\x130', '\x137', '\x140', '\x146', 
		'\x14A', '\x156', '\x15D', '\x167', '\x16D', '\x171', '\x17D', '\x184', 
		'\x18E', '\x19F', '\x1A8', '\x1AA', '\x1AE', '\x1B6', '\x1BE', '\x1C6', 
		'\x1D5', '\x1D7', '\x1E3', '\x1E5', '\x1F0', '\x1F4', '\x1F9', '\x200', 
		'\x20D', '\x20F', '\x21B', '\x222', '\x227', '\x22C', '\x234', '\x254', 
		'\x259', '\x25C',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
