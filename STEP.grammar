Package STEP;

Helpers
  tab = 9;
  cr = 13;
  lf = 10;
  eol = cr lf | cr | lf;
  lowercase = ['a' .. 'z'];
  uppercase = ['A' .. 'Z'];
  letter = lowercase | uppercase | '_';
  digit = ['0' .. '9'];
  letter_or_digit = letter | digit;

Tokens
  lparen = '(';
  rparan = ')';
  lbrack = '[';
  rbrack = ']';
  numliteral = digit+ | digit+ '.' digit*;
  strliteral = '\".*\"';
  boolliteral = 'true'|'false';
  id = letter letter_or_digit*;
  assign = '=';
  plus = '+';
  minus = '-';
  divide = '/';
  mult = '*';
  pow = '^';
  grthan = '>';
  grthaneq = '>=';
  lthan = '<';
  lthaneq = '<=';
  eq = '==';
  neq = '!=';
  neg = '!';
  nl = '\r?\n';
  whitespace = (' ' | tab | eol)+;
  comma = ',';

// Keywords
  setup = 'setup';
  endsetup = 'end setup';
  loop = 'loop';
  endloop = 'end loop';
  function = 'function';
  endfunction = 'end function';
  functions = 'functions';
  endfunctions = 'end functions';
  blank = 'blank';
  number = 'number';
  string = 'string';
  boolean = 'boolean';
  if = 'if';
  endif = 'end if';
  else = 'else';
  continue = 'continue';
  break = 'break';
  repeatwhile = 'repeat while';
  endwhile = 'end while';
  repeatfor = 'repeat for';
  endfor = 'end for';
  to = 'to';
  increaseby = 'increase by';
  decreaseby = 'decrease by';
  switch = 'switch';
  endswitch = 'end switch';
  when = 'when';
  do = 'do';
  fallthrough = 'fallthrough';
  otherwisedo = 'otherwise do';
  return = 'return';
  and = 'and';
  or = 'or';
  constant = 'constant';

Ignored Tokens
  whitespace;

Productions
  program = setuploop P.functions?;
  setuploop = {one} P.setup | {two} P.loop | {three} P.setup P.loop;
  setup = T.setup stmt* endsetup nl;
  loop = T.loop stmt* endloop nl;
  functions = T.functions funcdcl* endfunctions nl;
  funcdcl = type brackets? T.function id params stmt* retstmt endfunction nl | blank T.function id params stmt* endfunction nl;
  brackets = lbrack rbrack;
  params = lparen params_content? rparen;
  params_content = type brackets* id params_multi*;
  params_multi = comma type brackets* id;
  type = number | string | boolean;
  stmt = ifstmt nl | whilestmt nl | forstmt nl | vardcl nl | assstmt nl | funccall nl | retstmt nl | switchstmt nl | skipstmt nl;
  ifstmt = if lparen bexpr rparen stmt* endif | if lparen bexpr rparen stmt* else stmt* endif;
  whilestmt = repeatwhile lparen bexpr rparen option_stmt_continue_break* endwhile;
  option_stmt_continue_break = stmt | continue nl | break nl;
  forstmt = repeatfor lparen forstmt_iterator_options to aexpr comma option_increase_decrease aexpr rparen option_stmt_continue_break* endfor;
  forstmt_iterator_options = numdcl | assstmt | id arrindex?;
  option_increase_decrease = increase | decrease;
  switchstmt = switch lparen id arrindex? rparen whencase* otherwisecase? endswitch;
  whencase = when numliteral do stmt* fallthrough?;
  otherwisecase = otherwisedo stmt*;
  assstmt = id arrindex? assign expr;
  funccall = id lparen params_options? rparen;
  params_options = expr multi_expr*;
  multi_expr = comma expr;
  retstmt = return expr;
  arrindex = lbrack aexpr rbrack;
  skipstmt = nl;
  expr = aexpr | bexpr | sexpr;
  bexpr = neg? bexpr binary_bexpr? | aexpr relop aexpr | lparen bexpr rparen | id arrindex? | boolliteral | funccall;
  binary_bexpr = bop bexpr;
  relop = grthen | grthaneq | lthan | lthaneq | eq | neq;
  bop = and | or | eq | neq;
  sexpr = sexpr binary_sexpr? | id arrindex? | strliteral | funccall;
  binary_sexpr = plus sexpr;
  aexpr = aexpr plus_or_minus term | term;
  plus_or_minus = plus | minus;
  term = term mult_or_divide factor | factor;
  mult_or_divide = mult | divide;
  factor = exp pow factor | exp;
  exp = lparen aexpr rparen | minus? exp_alternatives;
  exp_alternatives = numliteral | id arrindex? | funccall;
  vardcl = constant? var_options nl;
  var_options = numdcl | stringdcl | booldcl | arrdcl;
  numdcl = number id assign aexpr nl;
  stringdcl = string id assign sexpr nl;
  booldcl = boolean id assign bexpr nl;
  arrdcl = type arrsizedcl arrsizedcl* id assign arr_id_or_expr;
  arr_id_or_expr = id | lbrack params_options? rbrack;
  arrsizedcl = lbrack numliteral rbrack;
