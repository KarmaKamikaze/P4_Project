Package STEP;

Helpers
  tab = 9;
  cr = 13;
  lf = 10;
  eol = cr lf | cr | lf;
  lowercase = ['a' .. 'z'];
  uppercase = ['A' .. 'Z'];
  letter = lowercase | uppercase | '_';
  digit = ['0' .. '9'];
  letter_or_digit = letter | digit;

Tokens
  lparen = '(';
  rparan = ')';
  lbrack = '[';
  rbrack = ']';
  numliteral = digit+ | digit+ '.' digit*;
  strliteral = '\".*\"';
  boolliteral = 'true'|'false';
  id = letter letter_or_digit*;
  assign = '=';
  plus = '+';
  minus = '-';
  divide = '/';
  mult = '*';
  pow = '^';
  grthan = '>';
  grthaneq = '>=';
  lthan = '<';
  lthaneq = '<=';
  eq = '==';
  neq = '!=';
  neg = '!';
  nl = '\r?\n';
  whitespace = (' ' | tab | eol)+;
  comma = ',';


  setup_keyword = 'setup';
  endsetup_keyword = 'end setup';
  loop_keyword = 'loop';
  endloop_keyword = 'end loop';
  function_keyword = 'function';
  endfunction_keyword = 'end function';
  functions_keyword = 'functions';
  endfunctions_keyword = 'end functions';
  blank_keyword = 'blank';
  number_keyword = 'number';
  string_keyword = 'string';
  boolean_keyword = 'boolean';
  if_keyword = 'if';
  endif_keyword = 'end if';
  else_keyword = 'else';
  continue_keyword = 'continue';
  break_keyword = 'break';
  repeatwhile_keyword = 'repeat while';
  endwhile_keyword = 'end while';
  repeatfor_keyword = 'repeat for';
  endfor_keyword = 'end for';
  to_keyword = 'to';
  increaseby_keyword = 'increase by';
  decreaseby_keyword = 'decrease by';
  switch_keyword = 'switch';
  endswitch_keyword = 'end switch';
  when_keyword = 'when';
  do_keyword = 'do';
  fallthrough_keyword = 'fallthrough';
  otherwisedo_keyword = 'otherwise do';
  return_keyword = 'return';
  and_keyword = 'and';
  or_keyword = 'or';
  constant_keyword = 'constant';
  number_keyword = 'number';
  string_keyword = 'string';
  boolean_keyword = 'boolean';

Ignored Tokens
  whitespace;

Productions
  program = (setup | loop | setup loop) [functions];
  setup = setup_keyword {stmt} endsetup_keyword nl;
  loop = loop_keyword {stmt} endloop_keyword nl;
  functions = functions_keyword {funcdcl} endfunctions_keyword nl;
  funcdcl = type [lbrack rbrack] function_keyword id params {stmt} retstmt endfunction_keyword nl | blank_keyword function_keyword id params {stmt} endfunction_keyword nl;
  params = lparen [type {lbrack rbrack} id {comma type {lbrack rbrack} id} rparen;
  type = number_keyword | string_keyword | boolean_keyword;
  stmt = (ifstmt | whilestmt | forstmt | vardcl | assstmt | funccall | retstmt | switchstmt | skipstmt) nl;
  ifstmt = if_keyword lparen bexpr rparen {stmt} endif_keyword | if_keyword lparen bexpr rparen {stmt} else_keyword {stmt} endif_keyword;
  whilestmt = repeatwhile_keyword lparen bexpr rparen {(stmt | continue_keyword nl | break_keyword nl)} endwhile_keyword;
  forstmt = repeatfor_keyword lparen (numdcl | assdcl | id [arrindex]) to_keyword aexpr comma (increaseby_keyword | decreaseby_keyword) aexpr rparen {(stmt | continue_keyword nl | break_keyword nl)} endfor_keyword;
  switchstmt = switch_keyword lparen id [arrindex] rparen {whencase} [otherwisecase] endswitch_keyword;
  whencase = when_keyword numliteral do_keyword {stmt} [fallthrough_keyword];
  otherwisecase = otherwisedo_keyword {stmt};
  assstmt = id [arrindex] assign expr;
  funccall = id lparen [expr {comma expr}] rparen;
  retstmt = return_keyword expr;
  arrindex = lbrack aexpr rbrack;
  skipstmt = nl;
  expr = (aexpr | bexpr | sexpr);
  bexpr = [neg] bexpr [bop bexpr] | aexpr relop aexpr | lparen bexpr rparen | id [arrindex] | boolliteral | funccall;
  relop = grthen | grthaneq | lthan | lthaneq | eq | neq;
  bop = and | or | eq | neq;
  sexpr = sexpr [plus sexpr] | id [arrindex] | strliteral | funccall;
  aexpr = aexpr (plus | minus) term | term;
  term = term (mult | divide) factor | factor;
  factor = exp pow factor | exp;
  exp = lparen aexpr rparen | [minus] (numliteral | id [arrindex] | funccall);
  vardcl = [constant_keyword] (numdcl | stringdcl | booldcl | arrdcl) nl;
  numdcl = number_keyword id assign aexpr nl;
  stringdcl = string_keyword id assign sexpr nl;
  booldcl = boolean_keyword id assign bexpr nl;
  arrdcl = type arrsizedcl {arrsizedcl} id assign (id | lbrack [expr {comma expr}] rbrack);
  arrsizedcl = lbrack numliteral rbrack;
