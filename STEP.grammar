Package STEP;

Helpers
  tab = 9;
  cr = 13;
  lf = 10;
  eol = cr lf | cr | lf;
  lowercase = ['a' .. 'z'];
  uppercase = ['A' .. 'Z'];
  letter = lowercase | uppercase | '_';
  digit = ['0' .. '9'];
  letter_or_digit = letter | digit;

Tokens
  lparen = '(';
  rparen = ')';
  lbrack = '[';
  rbrack = ']';
  numliteral = digit+ | digit+ '.' digit*;
  strliteral = '\".*\"';
  boolliteral = 'true'|'false';
  id = letter letter_or_digit*;
  assign = '=';
  plus = '+';
  minus = '-';
  divide = '/';
  mult = '*';
  pow = '^';
  grthan = '>';
  grthaneq = '>=';
  lthan = '<';
  lthaneq = '<=';
  eq = '==';
  neq = '!=';
  neg = '!';
  nl = '\r?\n';
  whitespace = (' ' | tab | eol)+;
  comma = ',';

// Keywords
  setup = 'setup';
  endsetup = 'end setup';
  loop = 'loop';
  endloop = 'end loop';
  function = 'function';
  endfunction = 'end function';
  functions = 'functions';
  endfunctions = 'end functions';
  blank = 'blank';
  number = 'number';
  string = 'string';
  boolean = 'boolean';
  if = 'if';
  endif = 'end if';
  else = 'else';
  continue = 'continue';
  break = 'break';
  repeatwhile = 'repeat while';
  endwhile = 'end while';
  repeatfor = 'repeat for';
  endfor = 'end for';
  to = 'to';
  increaseby = 'increase by';
  decreaseby = 'decrease by';
  switch = 'switch';
  endswitch = 'end switch';
  when = 'when';
  do = 'do';
  fallthrough = 'fallthrough';
  otherwisedo = 'otherwise do';
  return = 'return';
  and = 'and';
  or = 'or';
  constant = 'constant';

Ignored Tokens
  whitespace;

Productions
  program = setuploop P.functions?;
  setuploop = {one} P.setup | {two} P.loop | {three} P.setup P.loop;
  setup = T.setup stmt* endsetup nl;
  loop = T.loop stmt* endloop nl;
  functions = T.functions funcdcl* endfunctions nl;
  funcdcl = {one} type brackets? T.function id params stmt* retstmt endfunction nl | {two} blank T.function id params stmt* endfunction nl;
  brackets = lbrack rbrack;
  params = lparen params_content? rparen;
  params_content = type brackets* id params_multi*;
  params_multi = comma type brackets* id;
  type = {one} number | {two} string | {three} boolean;
  stmt = {one} ifstmt nl | {two} whilestmt nl | {three} forstmt nl | {four} vardcl nl | {five} assstmt nl | {six} funccall nl | {seven} retstmt nl | {eight} switchstmt nl | {nine} skipstmt nl;
  ifstmt = {nonelse} if lparen bexpr rparen stmt* endif | {withelse} if lparen bexpr rparen [fst]:stmt* else [snd]:stmt* endif;
  whilestmt = repeatwhile lparen bexpr rparen option_stmt_continue_break* endwhile;
  option_stmt_continue_break = {one} stmt | {two} continue nl | {three} break nl;
  forstmt = repeatfor lparen forstmt_iterator_options to [fst]:aexpr comma option_increase_decrease [snd]:aexpr rparen option_stmt_continue_break* endfor;
  forstmt_iterator_options = {one} numdcl | {two} assstmt | {three} id arrindex?;
  option_increase_decrease = {one} increaseby | {two} decreaseby;
  switchstmt = switch lparen id arrindex? rparen whencase* otherwisecase? endswitch;
  whencase = when numliteral do stmt* fallthrough?;
  otherwisecase = otherwisedo stmt*;
  assstmt = id arrindex? assign expr;
  funccall = id lparen params_options? rparen;
  params_options = expr multi_expr*;
  multi_expr = comma expr;
  retstmt = return expr;
  arrindex = lbrack aexpr rbrack;
  skipstmt = nl;
  expr = {one} aexpr | {two} bexpr | {three} sexpr;
  bexpr = {one} neg? bexpr binary_bexpr? | {two} [fst]:aexpr relop [snd]:aexpr | {three} lparen bexpr rparen | {four} id arrindex? | {five} boolliteral | {six} funccall;
  binary_bexpr = bop bexpr;
  relop = {one} grthan | {two} grthaneq | {three} lthan | {four} lthaneq | {five} eq | {six} neq;
  bop = {one} and | {two} or | {three} eq | {four} neq;
  sexpr = {one} sexpr binary_sexpr? | {two} id arrindex? | {three} strliteral | {four} funccall;
  binary_sexpr = plus sexpr;
  aexpr = {one} aexpr plus_or_minus term | {two} term;
  plus_or_minus = {one} plus | {two} minus;
  term = {one} term mult_or_divide factor | {two} factor;
  mult_or_divide = {one} mult | {two} divide;
  factor = {one} exp pow factor | {two} exp;
  exp = {one} lparen aexpr rparen | {two} minus? exp_alternatives;
  exp_alternatives = {one} numliteral | {two} id arrindex? | {three} funccall;
  vardcl = constant? var_options nl;
  var_options = {one} numdcl | {two} stringdcl | {three} booldcl | {four} arrdcl;
  numdcl = number id assign aexpr nl;
  stringdcl = string id assign sexpr nl;
  booldcl = boolean id assign bexpr nl;
  arrdcl = type [fst]:arrsizedcl [multi]:arrsizedcl* id assign arr_id_or_expr;
  arr_id_or_expr = {one} id | {two} lbrack params_options? rbrack;
  arrsizedcl = lbrack numliteral rbrack;
