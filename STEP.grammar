Package STEP;

Helpers
  tab = 9;
  cr = 13;
  lf = 10;
  eol = cr lf | cr | lf;
  lowercase = ['a' .. 'z'];
  uppercase = ['A' .. 'Z'];
  letter = lowercase | uppercase | '_';
  digit = ['0' .. '9'];
  letter_or_digit = letter | digit;

Tokens
  lparen = '(';
  rparan = ')';
  lbrack = '[';
  rbrack = ']';
  numliteral = digit+ | digit+ '.' digit*;
  strliteral = '\".*\"';
  boolliteral = 'true'|'false';
  id = letter letter_or_digit*;
  assign = '=';
  plus = '+';
  minus = '-';
  divide = '/';
  mult = '*';
  pow = '^';
  grthan = '>';
  grthaneq = '>=';
  lthan = '<';
  lthaneq = '<=';
  eq = '==';
  neq = '!=';
  neg = '!';
  nl = '\r?\n';
  whitespace = (' ' | tab | eol)+;
  comma = ',';


  setup = 'setup';
  endsetup = 'end setup';
  loop = 'loop';
  endloop = 'end loop';
  function = 'function';
  endfunction = 'end function';
  functions = 'functions';
  endfunctions = 'end functions';
  blank = 'blank';
  number = 'number';
  string = 'string';
  boolean = 'boolean';
  if = 'if';
  endif = 'end if';
  else = 'else';
  continue = 'continue';
  break = 'break';
  repeatwhile = 'repeat while';
  endwhile = 'end while';
  repeatfor = 'repeat for';
  endfor = 'end for';
  to = 'to';
  increaseby = 'increase by';
  decreaseby = 'decrease by';
  switch = 'switch';
  endswitch = 'end switch';
  when = 'when';
  do = 'do';
  fallthrough = 'fallthrough';
  otherwisedo = 'otherwise do';
  return = 'return';
  and = 'and';
  or = 'or';
  constant = 'constant';
  number = 'number';
  string = 'string';
  boolean = 'boolean';

Ignored Tokens
  whitespace;

Productions
  Program = (Setup | Loop | Setup Loop) [Functions];
  Setup = setup {Stmt} endsetup nl;
  Loop = loop {Stmt} endloop nl;
  Functions = functions {FuncDcl} endfunctions nl;
  FuncDcl = Type [lbrack rbrack] function id Params {Stmt} RetStmt endfunction nl | blank function id Params {Stmt} endfunction nl;
  Params = lparen [Type {lbrack rbrack} id {comma Type {lbrack rbrack} id} rparen;
  Type = number | string | boolean;
  Stmt = (IfStmt | WhileStmt | ForStmt | VarDcl | AssStmt | FuncCall | RetStmt | SwitchStmt | SkipStmt) nl;
  IfStmt = if lparen BExpr rparen {Stmt} endif | if lparen BExpr rparen {Stmt} else {Stmt} endif;
  WhileStmt = repeatwhile lparen BExpr rparen {(Stmt | continue nl | break nl)} endwhile;
  ForStmt = repeatfor lparen (NumDcl | AssDcl | id [ArrIndex]) to AExpr comma (increaseby | decreaseby) AExpr rparen {(Stmt | continue nl | break nl)} endfor;
  SwitchStmt = switch lparen id [ArrIndex] rparen {WhenCase} [OtherwiseCase] endswitch;
  WhenCase = when numliteral do {Stmt} [fallthrough];
  OtherwiseCase = otherwisedo {Stmt};
  AssStmt = id [ArrIndex] assign Expr;
  FuncCall = id lparen [Expr {comma Expr}] rparen;
  RetStmt = return Expr;
  ArrIndex = lbrack AExpr rbrack;
  SkipStmt = nl;
  Expr = (AExpr | BExpr | SExpr);
  BExpr = [neg] BExpr [BOp BExpr] | AExpr RelOp AExpr | lparen BExpr rparen | id [ArrIndex] | boolliteral | FuncCall;
  RelOp = grthen | grthaneq | lthan | lthaneq | eq | neq;
  BOp = and | or | eq | neq;
  SExpr = SExpr [plus SExpr] | id [ArrIndex] | strliteral | FuncCall;
  AExpr = AExpr (plus | minus) Term | Term;
  Term = Term (mult | divide) Factor | Factor;
  Factor = Exp pow Factor | Exp;
  Exp = lparen AExpr rparen | [minus] (numliteral | id [ArrIndex] | FuncCall);
  VarDcl = [constant] (NumDcl | StringDcl | BoolDcl | ArrDcl | StringArrDcl | BoolArrDcl) nl;
  NumDcl = number id assign AExpr nl;
  StringDcl = string id assign SExpr nl;
  BoolDcl = boolean id assign BExpr nl;
  ArrDcl = Type ArrSizeDcl {ArrSizeDcl} id assign (id | lbrack [Expr {comma Expr}] rbrack);
  ArrSizeDcl = lbrack numliteral rbrack;
