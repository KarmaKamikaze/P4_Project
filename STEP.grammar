Package STEP;

Helpers
  tab = 9;
  cr = 13;
  lf = 10;
  eol = cr lf | cr | lf;
  lowercase = ['a' .. 'z'];
  uppercase = ['A' .. 'Z'];
  letter = lowercase | uppercase | '_';
  digit = ['0' .. '9'];
  letter_or_digit = letter | digit;

Tokens
  lparen = '(';
  rparen = ')';
  lbrack = '[';
  rbrack = ']';
  numliteral = digit+ | digit+ '.' digit*;
  strliteral = '\".*\"';
  boolliteral = 'true'|'false';
  id = letter letter_or_digit*;
  assign = '=';
  plus = '+';
  minus = '-';
  divide = '/';
  mult = '*';
  pow = '^';
  grthan = '>';
  grthaneq = '>=';
  lthan = '<';
  lthaneq = '<=';
  eq = '==';
  neq = '!=';
  neg = '!';
  nl = '\r?\n';
  whitespace = (' ' | tab | eol)+;
  comma = ',';

// Keywords
  setup = 'setup';
  endsetup = 'end setup';
  loop = 'loop';
  endloop = 'end loop';
  function = 'function';
  endfunction = 'end function';
  globalvariables = 'globalvariables';
  endglobalvariables = 'end globalvariables';
  functions = 'functions';
  endfunctions = 'end functions';
  blank = 'blank';
  number = 'number';
  string = 'string';
  boolean = 'boolean';
  if = 'if';
  endif = 'end if';
  else = 'else';
  continue = 'continue';
  break = 'break';
  repeatwhile = 'repeat while';
  endwhile = 'end while';
  repeatfor = 'repeat for';
  endfor = 'end for';
  to = 'to';
  increaseby = 'increase by';
  decreaseby = 'decrease by';
  switch = 'switch';
  endswitch = 'end switch';
  when = 'when';
  do = 'do';
  fallthrough = 'fallthrough';
  otherwisedo = 'otherwise do';
  return = 'return';
  and = 'and';
  or = 'or';
  constant = 'constant';

Ignored Tokens
  whitespace;

Productions
  // Program
  program = P.globalvariables? setuploop P.functions?;
  setuploop = {one} P.setup | {two} P.loop | {three} P.setup P.loop;
  setup = T.setup stmt* endsetup nl;
  loop = T.loop stmt* endloop nl;
  
  // Global variable declarations
  globalvariables = T.globalvariables vardcl* endglobalvariables nl;
  
  // Function declarations
  functions = T.functions funcdcl* endfunctions nl;
  funcdcl = {one} type brackets* T.function id params stmt* retstmt endfunction nl | {two} blank T.function id params stmt* endfunction nl;
  brackets = lbrack rbrack;
  params = lparen params_content? rparen;
  params_content = type brackets* id params_multi*;
  params_multi = comma type brackets* id;
  type = {one} number | {two} string | {three} boolean;
  
  // Statements
  stmt = {one} ifstmt nl | {two} whilestmt nl | {three} forstmt nl | {four} vardcl nl | {five} assstmt nl | {six} funccall nl | {seven} retstmt nl | {eight} switchstmt nl | {nine} skipstmt nl;
  ifstmt = {nonelse} if lparen cond rparen stmt* endif | {withelse} if lparen cond rparen [fst]:stmt* else [snd]:stmt* endif;
  whilestmt = repeatwhile lparen cond rparen option_stmt_continue_break* endwhile;
  option_stmt_continue_break = {one} stmt | {two} continue nl | {three} break nl;
  forstmt = repeatfor lparen forstmt_iterator_options to [fst]:expr comma option_increase_decrease [snd]:expr rparen option_stmt_continue_break* endfor;
  forstmt_iterator_options = {one} numdcl | {two} assstmt | {three} id arrindex?;
  option_increase_decrease = {one} increaseby | {two} decreaseby;
  switchstmt = switch lparen id arrindex? rparen whencase* otherwisecase? endswitch;
  whencase = when numliteral do stmt* fallthrough?;
  otherwisecase = otherwisedo stmt*;
  assstmt = id arrindex? assign expr;
  funccall = id lparen params_options? rparen;
  params_options = expr multi_expr*;
  multi_expr = comma expr;
  retstmt = {one} return cond | {two} return;
  arrindex = lbrack expr rbrack;
  skipstmt = nl;
  
  // Arithmetic expressions
  expr = {one} value | {two} expr aop value;
  aop = {one} plus | {two} minus | {three} mult | {four} divide | {five} pow;
  value = {one} P.constant | {two} id arrindex? | {three} lparen expr rparen;
  constant = {one} numliteral | {two} strliteral | {three} boolliteral;
  
  // Boolean expressions
  comp = {one} expr | {two} [fst]:expr relop [snd]:expr;
  relop = {one} grthan | {two} grthaneq | {three} lthan | {four} lthaneq | {five} eq | {six} neq;
  cond = {one} comp | {two} [fst]:comp bop [snd]:cond;
  bop = {one} and | {two} or;
  
  // Variable declarations
  vardcl = T.constant? var_options nl;
  var_options = {one} numdcl | {two} stringdcl | {three} booldcl | {four} arrdcl;
  numdcl = number id assign expr nl;
  stringdcl = string id assign expr nl;
  booldcl = boolean id assign cond nl;
  arrdcl = type [fst]:arrsizedcl [multi]:arrsizedcl* id assign arr_id_or_expr;
 arr_id_or_expr = {one} id | {two} lbrack arr_lit* rbrack;
 arr_lit = {one} params_options? | {two}  lbrack params_options? rbrack | {three} lbrack params_options? rbrack comma 
 arr_lit;
  arrsizedcl = lbrack numliteral rbrack;
